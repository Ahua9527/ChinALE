"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/humanize-plus";
exports.ids = ["vendor-chunks/humanize-plus"];
exports.modules = {

/***/ "(ssr)/./node_modules/humanize-plus/dist/humanize.js":
/*!*****************************************************!*\
  !*** ./node_modules/humanize-plus/dist/humanize.js ***!
  \*****************************************************/
/***/ (function(module, exports) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* humanize.js - v1.8.2 */\n\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\n/**\n * Copyright 2013-2016 HubSpotDev\n * MIT Licensed\n *\n * @module humanize.js\n */\n\n(function (root, factory) {\n  if (( false ? 0 : _typeof(exports)) === 'object') {\n    module.exports = factory();\n  } else if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n      return root.Humanize = factory();\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n})(this, function () {\n  //------------------------------------------------------------------------------\n  // Constants\n  //------------------------------------------------------------------------------\n\n  var TIME_FORMATS = [{\n    name: 'second',\n    value: 1e3\n  }, {\n    name: 'minute',\n    value: 6e4\n  }, {\n    name: 'hour',\n    value: 36e5\n  }, {\n    name: 'day',\n    value: 864e5\n  }, {\n    name: 'week',\n    value: 6048e5\n  }];\n\n  var LABELS_FOR_POWERS_OF_KILO = {\n    P: Math.pow(2, 50),\n    T: Math.pow(2, 40),\n    G: Math.pow(2, 30),\n    M: Math.pow(2, 20)\n  };\n\n  //------------------------------------------------------------------------------\n  // Helpers\n  //------------------------------------------------------------------------------\n\n  var exists = function exists(maybe) {\n    return typeof maybe !== 'undefined' && maybe !== null;\n  };\n\n  var isNaN = function isNaN(value) {\n    return value !== value;\n  }; // eslint-disable-line\n\n  var isFiniteNumber = function isFiniteNumber(value) {\n    return isFinite(value) && !isNaN(parseFloat(value));\n  };\n\n  var isArray = function isArray(value) {\n    var type = Object.prototype.toString.call(value);\n    return type === '[object Array]';\n  };\n\n  //------------------------------------------------------------------------------\n  // Humanize\n  //------------------------------------------------------------------------------\n\n  var Humanize = {\n\n    // Converts a large integer to a friendly text representation.\n\n    intword: function intword(number, charWidth) {\n      var decimals = arguments.length <= 2 || arguments[2] === undefined ? 2 : arguments[2];\n\n      /*\n      * This method is deprecated. Please use compactInteger instead.\n      * intword will be going away in the next major version.\n      */\n      return Humanize.compactInteger(number, decimals);\n    },\n\n\n    // Converts an integer into its most compact representation\n    compactInteger: function compactInteger(input) {\n      var decimals = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];\n\n      decimals = Math.max(decimals, 0);\n      var number = parseInt(input, 10);\n      var signString = number < 0 ? '-' : '';\n      var unsignedNumber = Math.abs(number);\n      var unsignedNumberString = String(unsignedNumber);\n      var numberLength = unsignedNumberString.length;\n      var numberLengths = [13, 10, 7, 4];\n      var bigNumPrefixes = ['T', 'B', 'M', 'k'];\n\n      // small numbers\n      if (unsignedNumber < 1000) {\n        return '' + signString + unsignedNumberString;\n      }\n\n      // really big numbers\n      if (numberLength > numberLengths[0] + 3) {\n        return number.toExponential(decimals).replace('e+', 'x10^');\n      }\n\n      // 999 < unsignedNumber < 999,999,999,999,999\n      var length = void 0;\n      for (var i = 0; i < numberLengths.length; i++) {\n        var _length = numberLengths[i];\n        if (numberLength >= _length) {\n          length = _length;\n          break;\n        }\n      }\n\n      var decimalIndex = numberLength - length + 1;\n      var unsignedNumberCharacterArray = unsignedNumberString.split('');\n\n      var wholePartArray = unsignedNumberCharacterArray.slice(0, decimalIndex);\n      var decimalPartArray = unsignedNumberCharacterArray.slice(decimalIndex, decimalIndex + decimals + 1);\n\n      var wholePart = wholePartArray.join('');\n\n      // pad decimalPart if necessary\n      var decimalPart = decimalPartArray.join('');\n      if (decimalPart.length < decimals) {\n        decimalPart += '' + Array(decimals - decimalPart.length + 1).join('0');\n      }\n\n      var output = void 0;\n      if (decimals === 0) {\n        output = '' + signString + wholePart + bigNumPrefixes[numberLengths.indexOf(length)];\n      } else {\n        var outputNumber = Number(wholePart + '.' + decimalPart).toFixed(decimals);\n        output = '' + signString + outputNumber + bigNumPrefixes[numberLengths.indexOf(length)];\n      }\n\n      return output;\n    },\n\n\n    // Converts an integer to a string containing commas every three digits.\n    intComma: function intComma(number) {\n      var decimals = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];\n\n      return Humanize.formatNumber(number, decimals);\n    },\n    intcomma: function intcomma() {\n      return Humanize.intComma.apply(Humanize, arguments);\n    },\n\n\n    // Formats the value like a 'human-readable' file size (i.e. '13 KB', '4.1 MB', '102 bytes', etc).\n    fileSize: function fileSize(filesize) {\n      var precision = arguments.length <= 1 || arguments[1] === undefined ? 2 : arguments[1];\n\n      for (var label in LABELS_FOR_POWERS_OF_KILO) {\n        if (LABELS_FOR_POWERS_OF_KILO.hasOwnProperty(label)) {\n          var minnum = LABELS_FOR_POWERS_OF_KILO[label];\n          if (filesize >= minnum) {\n            return Humanize.formatNumber(filesize / minnum, precision, '') + ' ' + label + 'B';\n          }\n        }\n      }\n      if (filesize >= 1024) {\n        return Humanize.formatNumber(filesize / 1024, 0) + ' KB';\n      }\n\n      return Humanize.formatNumber(filesize, 0) + Humanize.pluralize(filesize, ' byte');\n    },\n    filesize: function filesize() {\n      return Humanize.fileSize.apply(Humanize, arguments);\n    },\n\n\n    // Formats a number to a human-readable string.\n    // Localize by overriding the precision, thousand and decimal arguments.\n    formatNumber: function formatNumber(number) {\n      var precision = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];\n      var thousand = arguments.length <= 2 || arguments[2] === undefined ? ',' : arguments[2];\n      var decimal = arguments.length <= 3 || arguments[3] === undefined ? '.' : arguments[3];\n\n      // Create some private utility functions to make the computational\n      // code that follows much easier to read.\n      var firstComma = function firstComma(_number, _thousand, _position) {\n        return _position ? _number.substr(0, _position) + _thousand : '';\n      };\n\n      var commas = function commas(_number, _thousand, _position) {\n        return _number.substr(_position).replace(/(\\d{3})(?=\\d)/g, '$1' + _thousand);\n      };\n\n      var decimals = function decimals(_number, _decimal, usePrecision) {\n        return usePrecision ? _decimal + Humanize.toFixed(Math.abs(_number), usePrecision).split('.')[1] : '';\n      };\n\n      var usePrecision = Humanize.normalizePrecision(precision);\n\n      // Do some calc\n      var negative = number < 0 && '-' || '';\n      var base = String(parseInt(Humanize.toFixed(Math.abs(number || 0), usePrecision), 10));\n      var mod = base.length > 3 ? base.length % 3 : 0;\n\n      // Format the number\n      return negative + firstComma(base, thousand, mod) + commas(base, thousand, mod) + decimals(number, decimal, usePrecision);\n    },\n\n\n    // Fixes binary rounding issues (eg. (0.615).toFixed(2) === '0.61')\n    toFixed: function toFixed(value, precision) {\n      precision = exists(precision) ? precision : Humanize.normalizePrecision(precision, 0);\n      var power = Math.pow(10, precision);\n\n      // Multiply up by precision, round accurately, then divide and use native toFixed()\n      return (Math.round(value * power) / power).toFixed(precision);\n    },\n\n\n    // Ensures precision value is a positive integer\n    normalizePrecision: function normalizePrecision(value, base) {\n      value = Math.round(Math.abs(value));\n      return isNaN(value) ? base : value;\n    },\n\n\n    // Converts an integer to its ordinal as a string.\n    ordinal: function ordinal(value) {\n      var number = parseInt(value, 10);\n\n      if (number === 0) {\n        return value;\n      }\n\n      var specialCase = number % 100;\n      if ([11, 12, 13].indexOf(specialCase) >= 0) {\n        return number + 'th';\n      }\n\n      var leastSignificant = number % 10;\n\n      var end = void 0;\n      switch (leastSignificant) {\n        case 1:\n          end = 'st';\n          break;\n        case 2:\n          end = 'nd';\n          break;\n        case 3:\n          end = 'rd';\n          break;\n        default:\n          end = 'th';\n      }\n\n      return '' + number + end;\n    },\n\n\n    // Interprets numbers as occurences. Also accepts an optional array/map of overrides.\n    times: function times(value) {\n      var overrides = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n      if (isFiniteNumber(value) && value >= 0) {\n        var number = parseFloat(value);\n        var smallTimes = ['never', 'once', 'twice'];\n        if (exists(overrides[number])) {\n          return String(overrides[number]);\n        }\n\n        var numberString = exists(smallTimes[number]) && smallTimes[number].toString();\n        return numberString || number.toString() + ' times';\n      }\n      return null;\n    },\n\n\n    // Returns the plural version of a given word if the value is not 1. The default suffix is 's'.\n    pluralize: function pluralize(number, singular, plural) {\n      if (!(exists(number) && exists(singular))) {\n        return null;\n      }\n\n      plural = exists(plural) ? plural : singular + 's';\n\n      return parseInt(number, 10) === 1 ? singular : plural;\n    },\n\n\n    // Truncates a string if it is longer than the specified number of characters (inclusive).\n    // Truncated strings will end with a translatable ellipsis sequence (\"â€¦\").\n    truncate: function truncate(str) {\n      var length = arguments.length <= 1 || arguments[1] === undefined ? 100 : arguments[1];\n      var ending = arguments.length <= 2 || arguments[2] === undefined ? '...' : arguments[2];\n\n      if (str.length > length) {\n        return str.substring(0, length - ending.length) + ending;\n      }\n      return str;\n    },\n\n\n    // Truncates a string after a certain number of words.\n    truncateWords: function truncateWords(string, length) {\n      var array = string.split(' ');\n      var result = '';\n      var i = 0;\n\n      while (i < length) {\n        if (exists(array[i])) {\n          result += array[i] + ' ';\n        }\n        i++;\n      }\n\n      if (array.length > length) {\n        return result + '...';\n      }\n\n      return null;\n    },\n    truncatewords: function truncatewords() {\n      return Humanize.truncateWords.apply(Humanize, arguments);\n    },\n\n\n    // Truncates a number to an upper bound.\n    boundedNumber: function boundedNumber(num) {\n      var bound = arguments.length <= 1 || arguments[1] === undefined ? 100 : arguments[1];\n      var ending = arguments.length <= 2 || arguments[2] === undefined ? '+' : arguments[2];\n\n      var result = void 0;\n\n      if (isFiniteNumber(num) && isFiniteNumber(bound)) {\n        if (num > bound) {\n          result = bound + ending;\n        }\n      }\n\n      return (result || num).toString();\n    },\n    truncatenumber: function truncatenumber() {\n      return Humanize.boundedNumber.apply(Humanize, arguments);\n    },\n\n\n    // Converts a list of items to a human readable string with an optional limit.\n    oxford: function oxford(items, limit, limitStr) {\n      var numItems = items.length;\n\n      var limitIndex = void 0;\n      if (numItems < 2) {\n        return String(items);\n      } else if (numItems === 2) {\n        return items.join(' and ');\n      } else if (exists(limit) && numItems > limit) {\n        var extra = numItems - limit;\n        limitIndex = limit;\n        limitStr = exists(limitStr) ? limitStr : ', and ' + extra + ' ' + Humanize.pluralize(extra, 'other');\n      } else {\n        limitIndex = -1;\n        limitStr = ', and ' + items[numItems - 1];\n      }\n\n      return items.slice(0, limitIndex).join(', ') + limitStr;\n    },\n\n\n    // Converts an object to a definition-like string\n    dictionary: function dictionary(object) {\n      var joiner = arguments.length <= 1 || arguments[1] === undefined ? ' is ' : arguments[1];\n      var separator = arguments.length <= 2 || arguments[2] === undefined ? ', ' : arguments[2];\n\n      var result = '';\n\n      if (exists(object) && (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && !isArray(object)) {\n        var defs = [];\n        for (var key in object) {\n          if (object.hasOwnProperty(key)) {\n            var val = object[key];\n            defs.push('' + key + joiner + val);\n          }\n        }\n\n        return defs.join(separator);\n      }\n\n      return result;\n    },\n\n\n    // Describes how many times an item appears in a list\n    frequency: function frequency(list, verb) {\n      if (!isArray(list)) {\n        return null;\n      }\n\n      var len = list.length;\n      var times = Humanize.times(len);\n\n      if (len === 0) {\n        return times + ' ' + verb;\n      }\n\n      return verb + ' ' + times;\n    },\n    pace: function pace(value, intervalMs) {\n      var unit = arguments.length <= 2 || arguments[2] === undefined ? 'time' : arguments[2];\n\n      if (value === 0 || intervalMs === 0) {\n        // Needs a better string than this...\n        return 'No ' + Humanize.pluralize(0, unit);\n      }\n\n      // Expose these as overridables?\n      var prefix = 'Approximately';\n      var timeUnit = void 0;\n      var relativePace = void 0;\n\n      var rate = value / intervalMs;\n      for (var i = 0; i < TIME_FORMATS.length; ++i) {\n        // assumes sorted list\n        var f = TIME_FORMATS[i];\n        relativePace = rate * f.value;\n        if (relativePace > 1) {\n          timeUnit = f.name;\n          break;\n        }\n      }\n\n      // Use the last time unit if there is nothing smaller\n      if (!timeUnit) {\n        prefix = 'Less than';\n        relativePace = 1;\n        timeUnit = TIME_FORMATS[TIME_FORMATS.length - 1].name;\n      }\n\n      var roundedPace = Math.round(relativePace);\n      unit = Humanize.pluralize(roundedPace, unit);\n\n      return prefix + ' ' + roundedPace + ' ' + unit + ' per ' + timeUnit;\n    },\n\n\n    // Converts newlines to <br/> tags\n    nl2br: function nl2br(string) {\n      var replacement = arguments.length <= 1 || arguments[1] === undefined ? '<br/>' : arguments[1];\n\n      return string.replace(/\\n/g, replacement);\n    },\n\n\n    // Converts <br/> tags to newlines\n    br2nl: function br2nl(string) {\n      var replacement = arguments.length <= 1 || arguments[1] === undefined ? '\\r\\n' : arguments[1];\n\n      return string.replace(/\\<br\\s*\\/?\\>/g, replacement);\n    },\n\n\n    // Capitalizes first letter in a string\n    capitalize: function capitalize(string) {\n      var downCaseTail = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];\n\n      return '' + string.charAt(0).toUpperCase() + (downCaseTail ? string.slice(1).toLowerCase() : string.slice(1));\n    },\n\n\n    // Capitalizes the first letter of each word in a string\n    capitalizeAll: function capitalizeAll(string) {\n      return string.replace(/(?:^|\\s)\\S/g, function (a) {\n        return a.toUpperCase();\n      });\n    },\n\n\n    // Titlecase words in a string.\n    titleCase: function titleCase(string) {\n      var smallWords = /\\b(a|an|and|at|but|by|de|en|for|if|in|of|on|or|the|to|via|vs?\\.?)\\b/i;\n      var internalCaps = /\\S+[A-Z]+\\S*/;\n      var splitOnWhiteSpaceRegex = /\\s+/;\n      var splitOnHyphensRegex = /-/;\n\n      var _doTitleCase = void 0;\n      _doTitleCase = function doTitleCase(_string) {\n        var hyphenated = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];\n        var firstOrLast = arguments.length <= 2 || arguments[2] === undefined ? true : arguments[2];\n\n        var titleCasedArray = [];\n        var stringArray = _string.split(hyphenated ? splitOnHyphensRegex : splitOnWhiteSpaceRegex);\n\n        for (var index = 0; index < stringArray.length; ++index) {\n          var word = stringArray[index];\n          if (word.indexOf('-') !== -1) {\n            titleCasedArray.push(_doTitleCase(word, true, index === 0 || index === stringArray.length - 1));\n            continue;\n          }\n\n          if (firstOrLast && (index === 0 || index === stringArray.length - 1)) {\n            titleCasedArray.push(internalCaps.test(word) ? word : Humanize.capitalize(word));\n            continue;\n          }\n\n          if (internalCaps.test(word)) {\n            titleCasedArray.push(word);\n          } else if (smallWords.test(word)) {\n            titleCasedArray.push(word.toLowerCase());\n          } else {\n            titleCasedArray.push(Humanize.capitalize(word));\n          }\n        }\n\n        return titleCasedArray.join(hyphenated ? '-' : ' ');\n      };\n\n      return _doTitleCase(string);\n    },\n    titlecase: function titlecase() {\n      return Humanize.titleCase.apply(Humanize, arguments);\n    }\n  };\n\n  return Humanize;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaHVtYW5pemUtcGx1cy9kaXN0L2h1bWFuaXplLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ2E7O0FBRWIscUdBQXFHLHFCQUFxQixtQkFBbUI7O0FBRTdJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU8sTUFBOEIsR0FBRyxDQUFXO0FBQ25EO0FBQ0EsSUFBSSxTQUFTLElBQTBDO0FBQ3ZELElBQUksaUNBQU8sRUFBRSxtQ0FBRTtBQUNmO0FBQ0EsS0FBSztBQUFBLGtHQUFDO0FBQ04sSUFBSSxLQUFLLEVBRU47QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0IsMEJBQTBCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzREFBc0QsRUFBRTtBQUN4RDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQSwrRUFBK0U7O0FBRS9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IseUJBQXlCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw0QkFBNEIsNEJBQTRCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9kZWFraW5zL0RvY3VtZW50cy9BTEUyR0JLLUNvbnZlcnRlci9ub2RlX21vZHVsZXMvaHVtYW5pemUtcGx1cy9kaXN0L2h1bWFuaXplLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGh1bWFuaXplLmpzIC0gdjEuOC4yICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG4vKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTYgSHViU3BvdERldlxuICogTUlUIExpY2Vuc2VkXG4gKlxuICogQG1vZHVsZSBodW1hbml6ZS5qc1xuICovXG5cbihmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuICBpZiAoKHR5cGVvZiBleHBvcnRzID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihleHBvcnRzKSkgPT09ICdvYmplY3QnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKFtdLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gcm9vdC5IdW1hbml6ZSA9IGZhY3RvcnkoKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICByb290Lkh1bWFuaXplID0gZmFjdG9yeSgpO1xuICB9XG59KSh0aGlzLCBmdW5jdGlvbiAoKSB7XG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIENvbnN0YW50c1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIHZhciBUSU1FX0ZPUk1BVFMgPSBbe1xuICAgIG5hbWU6ICdzZWNvbmQnLFxuICAgIHZhbHVlOiAxZTNcbiAgfSwge1xuICAgIG5hbWU6ICdtaW51dGUnLFxuICAgIHZhbHVlOiA2ZTRcbiAgfSwge1xuICAgIG5hbWU6ICdob3VyJyxcbiAgICB2YWx1ZTogMzZlNVxuICB9LCB7XG4gICAgbmFtZTogJ2RheScsXG4gICAgdmFsdWU6IDg2NGU1XG4gIH0sIHtcbiAgICBuYW1lOiAnd2VlaycsXG4gICAgdmFsdWU6IDYwNDhlNVxuICB9XTtcblxuICB2YXIgTEFCRUxTX0ZPUl9QT1dFUlNfT0ZfS0lMTyA9IHtcbiAgICBQOiBNYXRoLnBvdygyLCA1MCksXG4gICAgVDogTWF0aC5wb3coMiwgNDApLFxuICAgIEc6IE1hdGgucG93KDIsIDMwKSxcbiAgICBNOiBNYXRoLnBvdygyLCAyMClcbiAgfTtcblxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBIZWxwZXJzXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgdmFyIGV4aXN0cyA9IGZ1bmN0aW9uIGV4aXN0cyhtYXliZSkge1xuICAgIHJldHVybiB0eXBlb2YgbWF5YmUgIT09ICd1bmRlZmluZWQnICYmIG1heWJlICE9PSBudWxsO1xuICB9O1xuXG4gIHZhciBpc05hTiA9IGZ1bmN0aW9uIGlzTmFOKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbiAgfTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gIHZhciBpc0Zpbml0ZU51bWJlciA9IGZ1bmN0aW9uIGlzRmluaXRlTnVtYmVyKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzRmluaXRlKHZhbHVlKSAmJiAhaXNOYU4ocGFyc2VGbG9hdCh2YWx1ZSkpO1xuICB9O1xuXG4gIHZhciBpc0FycmF5ID0gZnVuY3Rpb24gaXNBcnJheSh2YWx1ZSkge1xuICAgIHZhciB0eXBlID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgICByZXR1cm4gdHlwZSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgfTtcblxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBIdW1hbml6ZVxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIHZhciBIdW1hbml6ZSA9IHtcblxuICAgIC8vIENvbnZlcnRzIGEgbGFyZ2UgaW50ZWdlciB0byBhIGZyaWVuZGx5IHRleHQgcmVwcmVzZW50YXRpb24uXG5cbiAgICBpbnR3b3JkOiBmdW5jdGlvbiBpbnR3b3JkKG51bWJlciwgY2hhcldpZHRoKSB7XG4gICAgICB2YXIgZGVjaW1hbHMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDIgfHwgYXJndW1lbnRzWzJdID09PSB1bmRlZmluZWQgPyAyIDogYXJndW1lbnRzWzJdO1xuXG4gICAgICAvKlxuICAgICAgKiBUaGlzIG1ldGhvZCBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIGNvbXBhY3RJbnRlZ2VyIGluc3RlYWQuXG4gICAgICAqIGludHdvcmQgd2lsbCBiZSBnb2luZyBhd2F5IGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24uXG4gICAgICAqL1xuICAgICAgcmV0dXJuIEh1bWFuaXplLmNvbXBhY3RJbnRlZ2VyKG51bWJlciwgZGVjaW1hbHMpO1xuICAgIH0sXG5cblxuICAgIC8vIENvbnZlcnRzIGFuIGludGVnZXIgaW50byBpdHMgbW9zdCBjb21wYWN0IHJlcHJlc2VudGF0aW9uXG4gICAgY29tcGFjdEludGVnZXI6IGZ1bmN0aW9uIGNvbXBhY3RJbnRlZ2VyKGlucHV0KSB7XG4gICAgICB2YXIgZGVjaW1hbHMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyAwIDogYXJndW1lbnRzWzFdO1xuXG4gICAgICBkZWNpbWFscyA9IE1hdGgubWF4KGRlY2ltYWxzLCAwKTtcbiAgICAgIHZhciBudW1iZXIgPSBwYXJzZUludChpbnB1dCwgMTApO1xuICAgICAgdmFyIHNpZ25TdHJpbmcgPSBudW1iZXIgPCAwID8gJy0nIDogJyc7XG4gICAgICB2YXIgdW5zaWduZWROdW1iZXIgPSBNYXRoLmFicyhudW1iZXIpO1xuICAgICAgdmFyIHVuc2lnbmVkTnVtYmVyU3RyaW5nID0gU3RyaW5nKHVuc2lnbmVkTnVtYmVyKTtcbiAgICAgIHZhciBudW1iZXJMZW5ndGggPSB1bnNpZ25lZE51bWJlclN0cmluZy5sZW5ndGg7XG4gICAgICB2YXIgbnVtYmVyTGVuZ3RocyA9IFsxMywgMTAsIDcsIDRdO1xuICAgICAgdmFyIGJpZ051bVByZWZpeGVzID0gWydUJywgJ0InLCAnTScsICdrJ107XG5cbiAgICAgIC8vIHNtYWxsIG51bWJlcnNcbiAgICAgIGlmICh1bnNpZ25lZE51bWJlciA8IDEwMDApIHtcbiAgICAgICAgcmV0dXJuICcnICsgc2lnblN0cmluZyArIHVuc2lnbmVkTnVtYmVyU3RyaW5nO1xuICAgICAgfVxuXG4gICAgICAvLyByZWFsbHkgYmlnIG51bWJlcnNcbiAgICAgIGlmIChudW1iZXJMZW5ndGggPiBudW1iZXJMZW5ndGhzWzBdICsgMykge1xuICAgICAgICByZXR1cm4gbnVtYmVyLnRvRXhwb25lbnRpYWwoZGVjaW1hbHMpLnJlcGxhY2UoJ2UrJywgJ3gxMF4nKTtcbiAgICAgIH1cblxuICAgICAgLy8gOTk5IDwgdW5zaWduZWROdW1iZXIgPCA5OTksOTk5LDk5OSw5OTksOTk5XG4gICAgICB2YXIgbGVuZ3RoID0gdm9pZCAwO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1iZXJMZW5ndGhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBfbGVuZ3RoID0gbnVtYmVyTGVuZ3Roc1tpXTtcbiAgICAgICAgaWYgKG51bWJlckxlbmd0aCA+PSBfbGVuZ3RoKSB7XG4gICAgICAgICAgbGVuZ3RoID0gX2xlbmd0aDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgZGVjaW1hbEluZGV4ID0gbnVtYmVyTGVuZ3RoIC0gbGVuZ3RoICsgMTtcbiAgICAgIHZhciB1bnNpZ25lZE51bWJlckNoYXJhY3RlckFycmF5ID0gdW5zaWduZWROdW1iZXJTdHJpbmcuc3BsaXQoJycpO1xuXG4gICAgICB2YXIgd2hvbGVQYXJ0QXJyYXkgPSB1bnNpZ25lZE51bWJlckNoYXJhY3RlckFycmF5LnNsaWNlKDAsIGRlY2ltYWxJbmRleCk7XG4gICAgICB2YXIgZGVjaW1hbFBhcnRBcnJheSA9IHVuc2lnbmVkTnVtYmVyQ2hhcmFjdGVyQXJyYXkuc2xpY2UoZGVjaW1hbEluZGV4LCBkZWNpbWFsSW5kZXggKyBkZWNpbWFscyArIDEpO1xuXG4gICAgICB2YXIgd2hvbGVQYXJ0ID0gd2hvbGVQYXJ0QXJyYXkuam9pbignJyk7XG5cbiAgICAgIC8vIHBhZCBkZWNpbWFsUGFydCBpZiBuZWNlc3NhcnlcbiAgICAgIHZhciBkZWNpbWFsUGFydCA9IGRlY2ltYWxQYXJ0QXJyYXkuam9pbignJyk7XG4gICAgICBpZiAoZGVjaW1hbFBhcnQubGVuZ3RoIDwgZGVjaW1hbHMpIHtcbiAgICAgICAgZGVjaW1hbFBhcnQgKz0gJycgKyBBcnJheShkZWNpbWFscyAtIGRlY2ltYWxQYXJ0Lmxlbmd0aCArIDEpLmpvaW4oJzAnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG91dHB1dCA9IHZvaWQgMDtcbiAgICAgIGlmIChkZWNpbWFscyA9PT0gMCkge1xuICAgICAgICBvdXRwdXQgPSAnJyArIHNpZ25TdHJpbmcgKyB3aG9sZVBhcnQgKyBiaWdOdW1QcmVmaXhlc1tudW1iZXJMZW5ndGhzLmluZGV4T2YobGVuZ3RoKV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgb3V0cHV0TnVtYmVyID0gTnVtYmVyKHdob2xlUGFydCArICcuJyArIGRlY2ltYWxQYXJ0KS50b0ZpeGVkKGRlY2ltYWxzKTtcbiAgICAgICAgb3V0cHV0ID0gJycgKyBzaWduU3RyaW5nICsgb3V0cHV0TnVtYmVyICsgYmlnTnVtUHJlZml4ZXNbbnVtYmVyTGVuZ3Rocy5pbmRleE9mKGxlbmd0aCldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH0sXG5cblxuICAgIC8vIENvbnZlcnRzIGFuIGludGVnZXIgdG8gYSBzdHJpbmcgY29udGFpbmluZyBjb21tYXMgZXZlcnkgdGhyZWUgZGlnaXRzLlxuICAgIGludENvbW1hOiBmdW5jdGlvbiBpbnRDb21tYShudW1iZXIpIHtcbiAgICAgIHZhciBkZWNpbWFscyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IDAgOiBhcmd1bWVudHNbMV07XG5cbiAgICAgIHJldHVybiBIdW1hbml6ZS5mb3JtYXROdW1iZXIobnVtYmVyLCBkZWNpbWFscyk7XG4gICAgfSxcbiAgICBpbnRjb21tYTogZnVuY3Rpb24gaW50Y29tbWEoKSB7XG4gICAgICByZXR1cm4gSHVtYW5pemUuaW50Q29tbWEuYXBwbHkoSHVtYW5pemUsIGFyZ3VtZW50cyk7XG4gICAgfSxcblxuXG4gICAgLy8gRm9ybWF0cyB0aGUgdmFsdWUgbGlrZSBhICdodW1hbi1yZWFkYWJsZScgZmlsZSBzaXplIChpLmUuICcxMyBLQicsICc0LjEgTUInLCAnMTAyIGJ5dGVzJywgZXRjKS5cbiAgICBmaWxlU2l6ZTogZnVuY3Rpb24gZmlsZVNpemUoZmlsZXNpemUpIHtcbiAgICAgIHZhciBwcmVjaXNpb24gPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyAyIDogYXJndW1lbnRzWzFdO1xuXG4gICAgICBmb3IgKHZhciBsYWJlbCBpbiBMQUJFTFNfRk9SX1BPV0VSU19PRl9LSUxPKSB7XG4gICAgICAgIGlmIChMQUJFTFNfRk9SX1BPV0VSU19PRl9LSUxPLmhhc093blByb3BlcnR5KGxhYmVsKSkge1xuICAgICAgICAgIHZhciBtaW5udW0gPSBMQUJFTFNfRk9SX1BPV0VSU19PRl9LSUxPW2xhYmVsXTtcbiAgICAgICAgICBpZiAoZmlsZXNpemUgPj0gbWlubnVtKSB7XG4gICAgICAgICAgICByZXR1cm4gSHVtYW5pemUuZm9ybWF0TnVtYmVyKGZpbGVzaXplIC8gbWlubnVtLCBwcmVjaXNpb24sICcnKSArICcgJyArIGxhYmVsICsgJ0InO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZpbGVzaXplID49IDEwMjQpIHtcbiAgICAgICAgcmV0dXJuIEh1bWFuaXplLmZvcm1hdE51bWJlcihmaWxlc2l6ZSAvIDEwMjQsIDApICsgJyBLQic7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBIdW1hbml6ZS5mb3JtYXROdW1iZXIoZmlsZXNpemUsIDApICsgSHVtYW5pemUucGx1cmFsaXplKGZpbGVzaXplLCAnIGJ5dGUnKTtcbiAgICB9LFxuICAgIGZpbGVzaXplOiBmdW5jdGlvbiBmaWxlc2l6ZSgpIHtcbiAgICAgIHJldHVybiBIdW1hbml6ZS5maWxlU2l6ZS5hcHBseShIdW1hbml6ZSwgYXJndW1lbnRzKTtcbiAgICB9LFxuXG5cbiAgICAvLyBGb3JtYXRzIGEgbnVtYmVyIHRvIGEgaHVtYW4tcmVhZGFibGUgc3RyaW5nLlxuICAgIC8vIExvY2FsaXplIGJ5IG92ZXJyaWRpbmcgdGhlIHByZWNpc2lvbiwgdGhvdXNhbmQgYW5kIGRlY2ltYWwgYXJndW1lbnRzLlxuICAgIGZvcm1hdE51bWJlcjogZnVuY3Rpb24gZm9ybWF0TnVtYmVyKG51bWJlcikge1xuICAgICAgdmFyIHByZWNpc2lvbiA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IDAgOiBhcmd1bWVudHNbMV07XG4gICAgICB2YXIgdGhvdXNhbmQgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDIgfHwgYXJndW1lbnRzWzJdID09PSB1bmRlZmluZWQgPyAnLCcgOiBhcmd1bWVudHNbMl07XG4gICAgICB2YXIgZGVjaW1hbCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMyB8fCBhcmd1bWVudHNbM10gPT09IHVuZGVmaW5lZCA/ICcuJyA6IGFyZ3VtZW50c1szXTtcblxuICAgICAgLy8gQ3JlYXRlIHNvbWUgcHJpdmF0ZSB1dGlsaXR5IGZ1bmN0aW9ucyB0byBtYWtlIHRoZSBjb21wdXRhdGlvbmFsXG4gICAgICAvLyBjb2RlIHRoYXQgZm9sbG93cyBtdWNoIGVhc2llciB0byByZWFkLlxuICAgICAgdmFyIGZpcnN0Q29tbWEgPSBmdW5jdGlvbiBmaXJzdENvbW1hKF9udW1iZXIsIF90aG91c2FuZCwgX3Bvc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiBfcG9zaXRpb24gPyBfbnVtYmVyLnN1YnN0cigwLCBfcG9zaXRpb24pICsgX3Rob3VzYW5kIDogJyc7XG4gICAgICB9O1xuXG4gICAgICB2YXIgY29tbWFzID0gZnVuY3Rpb24gY29tbWFzKF9udW1iZXIsIF90aG91c2FuZCwgX3Bvc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiBfbnVtYmVyLnN1YnN0cihfcG9zaXRpb24pLnJlcGxhY2UoLyhcXGR7M30pKD89XFxkKS9nLCAnJDEnICsgX3Rob3VzYW5kKTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBkZWNpbWFscyA9IGZ1bmN0aW9uIGRlY2ltYWxzKF9udW1iZXIsIF9kZWNpbWFsLCB1c2VQcmVjaXNpb24pIHtcbiAgICAgICAgcmV0dXJuIHVzZVByZWNpc2lvbiA/IF9kZWNpbWFsICsgSHVtYW5pemUudG9GaXhlZChNYXRoLmFicyhfbnVtYmVyKSwgdXNlUHJlY2lzaW9uKS5zcGxpdCgnLicpWzFdIDogJyc7XG4gICAgICB9O1xuXG4gICAgICB2YXIgdXNlUHJlY2lzaW9uID0gSHVtYW5pemUubm9ybWFsaXplUHJlY2lzaW9uKHByZWNpc2lvbik7XG5cbiAgICAgIC8vIERvIHNvbWUgY2FsY1xuICAgICAgdmFyIG5lZ2F0aXZlID0gbnVtYmVyIDwgMCAmJiAnLScgfHwgJyc7XG4gICAgICB2YXIgYmFzZSA9IFN0cmluZyhwYXJzZUludChIdW1hbml6ZS50b0ZpeGVkKE1hdGguYWJzKG51bWJlciB8fCAwKSwgdXNlUHJlY2lzaW9uKSwgMTApKTtcbiAgICAgIHZhciBtb2QgPSBiYXNlLmxlbmd0aCA+IDMgPyBiYXNlLmxlbmd0aCAlIDMgOiAwO1xuXG4gICAgICAvLyBGb3JtYXQgdGhlIG51bWJlclxuICAgICAgcmV0dXJuIG5lZ2F0aXZlICsgZmlyc3RDb21tYShiYXNlLCB0aG91c2FuZCwgbW9kKSArIGNvbW1hcyhiYXNlLCB0aG91c2FuZCwgbW9kKSArIGRlY2ltYWxzKG51bWJlciwgZGVjaW1hbCwgdXNlUHJlY2lzaW9uKTtcbiAgICB9LFxuXG5cbiAgICAvLyBGaXhlcyBiaW5hcnkgcm91bmRpbmcgaXNzdWVzIChlZy4gKDAuNjE1KS50b0ZpeGVkKDIpID09PSAnMC42MScpXG4gICAgdG9GaXhlZDogZnVuY3Rpb24gdG9GaXhlZCh2YWx1ZSwgcHJlY2lzaW9uKSB7XG4gICAgICBwcmVjaXNpb24gPSBleGlzdHMocHJlY2lzaW9uKSA/IHByZWNpc2lvbiA6IEh1bWFuaXplLm5vcm1hbGl6ZVByZWNpc2lvbihwcmVjaXNpb24sIDApO1xuICAgICAgdmFyIHBvd2VyID0gTWF0aC5wb3coMTAsIHByZWNpc2lvbik7XG5cbiAgICAgIC8vIE11bHRpcGx5IHVwIGJ5IHByZWNpc2lvbiwgcm91bmQgYWNjdXJhdGVseSwgdGhlbiBkaXZpZGUgYW5kIHVzZSBuYXRpdmUgdG9GaXhlZCgpXG4gICAgICByZXR1cm4gKE1hdGgucm91bmQodmFsdWUgKiBwb3dlcikgLyBwb3dlcikudG9GaXhlZChwcmVjaXNpb24pO1xuICAgIH0sXG5cblxuICAgIC8vIEVuc3VyZXMgcHJlY2lzaW9uIHZhbHVlIGlzIGEgcG9zaXRpdmUgaW50ZWdlclxuICAgIG5vcm1hbGl6ZVByZWNpc2lvbjogZnVuY3Rpb24gbm9ybWFsaXplUHJlY2lzaW9uKHZhbHVlLCBiYXNlKSB7XG4gICAgICB2YWx1ZSA9IE1hdGgucm91bmQoTWF0aC5hYnModmFsdWUpKTtcbiAgICAgIHJldHVybiBpc05hTih2YWx1ZSkgPyBiYXNlIDogdmFsdWU7XG4gICAgfSxcblxuXG4gICAgLy8gQ29udmVydHMgYW4gaW50ZWdlciB0byBpdHMgb3JkaW5hbCBhcyBhIHN0cmluZy5cbiAgICBvcmRpbmFsOiBmdW5jdGlvbiBvcmRpbmFsKHZhbHVlKSB7XG4gICAgICB2YXIgbnVtYmVyID0gcGFyc2VJbnQodmFsdWUsIDEwKTtcblxuICAgICAgaWYgKG51bWJlciA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBzcGVjaWFsQ2FzZSA9IG51bWJlciAlIDEwMDtcbiAgICAgIGlmIChbMTEsIDEyLCAxM10uaW5kZXhPZihzcGVjaWFsQ2FzZSkgPj0gMCkge1xuICAgICAgICByZXR1cm4gbnVtYmVyICsgJ3RoJztcbiAgICAgIH1cblxuICAgICAgdmFyIGxlYXN0U2lnbmlmaWNhbnQgPSBudW1iZXIgJSAxMDtcblxuICAgICAgdmFyIGVuZCA9IHZvaWQgMDtcbiAgICAgIHN3aXRjaCAobGVhc3RTaWduaWZpY2FudCkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgZW5kID0gJ3N0JztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIGVuZCA9ICduZCc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBlbmQgPSAncmQnO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGVuZCA9ICd0aCc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAnJyArIG51bWJlciArIGVuZDtcbiAgICB9LFxuXG5cbiAgICAvLyBJbnRlcnByZXRzIG51bWJlcnMgYXMgb2NjdXJlbmNlcy4gQWxzbyBhY2NlcHRzIGFuIG9wdGlvbmFsIGFycmF5L21hcCBvZiBvdmVycmlkZXMuXG4gICAgdGltZXM6IGZ1bmN0aW9uIHRpbWVzKHZhbHVlKSB7XG4gICAgICB2YXIgb3ZlcnJpZGVzID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMV07XG5cbiAgICAgIGlmIChpc0Zpbml0ZU51bWJlcih2YWx1ZSkgJiYgdmFsdWUgPj0gMCkge1xuICAgICAgICB2YXIgbnVtYmVyID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgICAgIHZhciBzbWFsbFRpbWVzID0gWyduZXZlcicsICdvbmNlJywgJ3R3aWNlJ107XG4gICAgICAgIGlmIChleGlzdHMob3ZlcnJpZGVzW251bWJlcl0pKSB7XG4gICAgICAgICAgcmV0dXJuIFN0cmluZyhvdmVycmlkZXNbbnVtYmVyXSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbnVtYmVyU3RyaW5nID0gZXhpc3RzKHNtYWxsVGltZXNbbnVtYmVyXSkgJiYgc21hbGxUaW1lc1tudW1iZXJdLnRvU3RyaW5nKCk7XG4gICAgICAgIHJldHVybiBudW1iZXJTdHJpbmcgfHwgbnVtYmVyLnRvU3RyaW5nKCkgKyAnIHRpbWVzJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG5cblxuICAgIC8vIFJldHVybnMgdGhlIHBsdXJhbCB2ZXJzaW9uIG9mIGEgZ2l2ZW4gd29yZCBpZiB0aGUgdmFsdWUgaXMgbm90IDEuIFRoZSBkZWZhdWx0IHN1ZmZpeCBpcyAncycuXG4gICAgcGx1cmFsaXplOiBmdW5jdGlvbiBwbHVyYWxpemUobnVtYmVyLCBzaW5ndWxhciwgcGx1cmFsKSB7XG4gICAgICBpZiAoIShleGlzdHMobnVtYmVyKSAmJiBleGlzdHMoc2luZ3VsYXIpKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcGx1cmFsID0gZXhpc3RzKHBsdXJhbCkgPyBwbHVyYWwgOiBzaW5ndWxhciArICdzJztcblxuICAgICAgcmV0dXJuIHBhcnNlSW50KG51bWJlciwgMTApID09PSAxID8gc2luZ3VsYXIgOiBwbHVyYWw7XG4gICAgfSxcblxuXG4gICAgLy8gVHJ1bmNhdGVzIGEgc3RyaW5nIGlmIGl0IGlzIGxvbmdlciB0aGFuIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIGNoYXJhY3RlcnMgKGluY2x1c2l2ZSkuXG4gICAgLy8gVHJ1bmNhdGVkIHN0cmluZ3Mgd2lsbCBlbmQgd2l0aCBhIHRyYW5zbGF0YWJsZSBlbGxpcHNpcyBzZXF1ZW5jZSAoXCLigKZcIikuXG4gICAgdHJ1bmNhdGU6IGZ1bmN0aW9uIHRydW5jYXRlKHN0cikge1xuICAgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IDEwMCA6IGFyZ3VtZW50c1sxXTtcbiAgICAgIHZhciBlbmRpbmcgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDIgfHwgYXJndW1lbnRzWzJdID09PSB1bmRlZmluZWQgPyAnLi4uJyA6IGFyZ3VtZW50c1syXTtcblxuICAgICAgaWYgKHN0ci5sZW5ndGggPiBsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHN0ci5zdWJzdHJpbmcoMCwgbGVuZ3RoIC0gZW5kaW5nLmxlbmd0aCkgKyBlbmRpbmc7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH0sXG5cblxuICAgIC8vIFRydW5jYXRlcyBhIHN0cmluZyBhZnRlciBhIGNlcnRhaW4gbnVtYmVyIG9mIHdvcmRzLlxuICAgIHRydW5jYXRlV29yZHM6IGZ1bmN0aW9uIHRydW5jYXRlV29yZHMoc3RyaW5nLCBsZW5ndGgpIHtcbiAgICAgIHZhciBhcnJheSA9IHN0cmluZy5zcGxpdCgnICcpO1xuICAgICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgICAgdmFyIGkgPSAwO1xuXG4gICAgICB3aGlsZSAoaSA8IGxlbmd0aCkge1xuICAgICAgICBpZiAoZXhpc3RzKGFycmF5W2ldKSkge1xuICAgICAgICAgIHJlc3VsdCArPSBhcnJheVtpXSArICcgJztcbiAgICAgICAgfVxuICAgICAgICBpKys7XG4gICAgICB9XG5cbiAgICAgIGlmIChhcnJheS5sZW5ndGggPiBsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCArICcuLi4nO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIHRydW5jYXRld29yZHM6IGZ1bmN0aW9uIHRydW5jYXRld29yZHMoKSB7XG4gICAgICByZXR1cm4gSHVtYW5pemUudHJ1bmNhdGVXb3Jkcy5hcHBseShIdW1hbml6ZSwgYXJndW1lbnRzKTtcbiAgICB9LFxuXG5cbiAgICAvLyBUcnVuY2F0ZXMgYSBudW1iZXIgdG8gYW4gdXBwZXIgYm91bmQuXG4gICAgYm91bmRlZE51bWJlcjogZnVuY3Rpb24gYm91bmRlZE51bWJlcihudW0pIHtcbiAgICAgIHZhciBib3VuZCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IDEwMCA6IGFyZ3VtZW50c1sxXTtcbiAgICAgIHZhciBlbmRpbmcgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDIgfHwgYXJndW1lbnRzWzJdID09PSB1bmRlZmluZWQgPyAnKycgOiBhcmd1bWVudHNbMl07XG5cbiAgICAgIHZhciByZXN1bHQgPSB2b2lkIDA7XG5cbiAgICAgIGlmIChpc0Zpbml0ZU51bWJlcihudW0pICYmIGlzRmluaXRlTnVtYmVyKGJvdW5kKSkge1xuICAgICAgICBpZiAobnVtID4gYm91bmQpIHtcbiAgICAgICAgICByZXN1bHQgPSBib3VuZCArIGVuZGluZztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gKHJlc3VsdCB8fCBudW0pLnRvU3RyaW5nKCk7XG4gICAgfSxcbiAgICB0cnVuY2F0ZW51bWJlcjogZnVuY3Rpb24gdHJ1bmNhdGVudW1iZXIoKSB7XG4gICAgICByZXR1cm4gSHVtYW5pemUuYm91bmRlZE51bWJlci5hcHBseShIdW1hbml6ZSwgYXJndW1lbnRzKTtcbiAgICB9LFxuXG5cbiAgICAvLyBDb252ZXJ0cyBhIGxpc3Qgb2YgaXRlbXMgdG8gYSBodW1hbiByZWFkYWJsZSBzdHJpbmcgd2l0aCBhbiBvcHRpb25hbCBsaW1pdC5cbiAgICBveGZvcmQ6IGZ1bmN0aW9uIG94Zm9yZChpdGVtcywgbGltaXQsIGxpbWl0U3RyKSB7XG4gICAgICB2YXIgbnVtSXRlbXMgPSBpdGVtcy5sZW5ndGg7XG5cbiAgICAgIHZhciBsaW1pdEluZGV4ID0gdm9pZCAwO1xuICAgICAgaWYgKG51bUl0ZW1zIDwgMikge1xuICAgICAgICByZXR1cm4gU3RyaW5nKGl0ZW1zKTtcbiAgICAgIH0gZWxzZSBpZiAobnVtSXRlbXMgPT09IDIpIHtcbiAgICAgICAgcmV0dXJuIGl0ZW1zLmpvaW4oJyBhbmQgJyk7XG4gICAgICB9IGVsc2UgaWYgKGV4aXN0cyhsaW1pdCkgJiYgbnVtSXRlbXMgPiBsaW1pdCkge1xuICAgICAgICB2YXIgZXh0cmEgPSBudW1JdGVtcyAtIGxpbWl0O1xuICAgICAgICBsaW1pdEluZGV4ID0gbGltaXQ7XG4gICAgICAgIGxpbWl0U3RyID0gZXhpc3RzKGxpbWl0U3RyKSA/IGxpbWl0U3RyIDogJywgYW5kICcgKyBleHRyYSArICcgJyArIEh1bWFuaXplLnBsdXJhbGl6ZShleHRyYSwgJ290aGVyJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaW1pdEluZGV4ID0gLTE7XG4gICAgICAgIGxpbWl0U3RyID0gJywgYW5kICcgKyBpdGVtc1tudW1JdGVtcyAtIDFdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaXRlbXMuc2xpY2UoMCwgbGltaXRJbmRleCkuam9pbignLCAnKSArIGxpbWl0U3RyO1xuICAgIH0sXG5cblxuICAgIC8vIENvbnZlcnRzIGFuIG9iamVjdCB0byBhIGRlZmluaXRpb24tbGlrZSBzdHJpbmdcbiAgICBkaWN0aW9uYXJ5OiBmdW5jdGlvbiBkaWN0aW9uYXJ5KG9iamVjdCkge1xuICAgICAgdmFyIGpvaW5lciA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/ICcgaXMgJyA6IGFyZ3VtZW50c1sxXTtcbiAgICAgIHZhciBzZXBhcmF0b3IgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDIgfHwgYXJndW1lbnRzWzJdID09PSB1bmRlZmluZWQgPyAnLCAnIDogYXJndW1lbnRzWzJdO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gJyc7XG5cbiAgICAgIGlmIChleGlzdHMob2JqZWN0KSAmJiAodHlwZW9mIG9iamVjdCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2Yob2JqZWN0KSkgPT09ICdvYmplY3QnICYmICFpc0FycmF5KG9iamVjdCkpIHtcbiAgICAgICAgdmFyIGRlZnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAgICAgIGlmIChvYmplY3QuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgdmFyIHZhbCA9IG9iamVjdFtrZXldO1xuICAgICAgICAgICAgZGVmcy5wdXNoKCcnICsga2V5ICsgam9pbmVyICsgdmFsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVmcy5qb2luKHNlcGFyYXRvcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuXG4gICAgLy8gRGVzY3JpYmVzIGhvdyBtYW55IHRpbWVzIGFuIGl0ZW0gYXBwZWFycyBpbiBhIGxpc3RcbiAgICBmcmVxdWVuY3k6IGZ1bmN0aW9uIGZyZXF1ZW5jeShsaXN0LCB2ZXJiKSB7XG4gICAgICBpZiAoIWlzQXJyYXkobGlzdCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBsZW4gPSBsaXN0Lmxlbmd0aDtcbiAgICAgIHZhciB0aW1lcyA9IEh1bWFuaXplLnRpbWVzKGxlbik7XG5cbiAgICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRpbWVzICsgJyAnICsgdmVyYjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZlcmIgKyAnICcgKyB0aW1lcztcbiAgICB9LFxuICAgIHBhY2U6IGZ1bmN0aW9uIHBhY2UodmFsdWUsIGludGVydmFsTXMpIHtcbiAgICAgIHZhciB1bml0ID0gYXJndW1lbnRzLmxlbmd0aCA8PSAyIHx8IGFyZ3VtZW50c1syXSA9PT0gdW5kZWZpbmVkID8gJ3RpbWUnIDogYXJndW1lbnRzWzJdO1xuXG4gICAgICBpZiAodmFsdWUgPT09IDAgfHwgaW50ZXJ2YWxNcyA9PT0gMCkge1xuICAgICAgICAvLyBOZWVkcyBhIGJldHRlciBzdHJpbmcgdGhhbiB0aGlzLi4uXG4gICAgICAgIHJldHVybiAnTm8gJyArIEh1bWFuaXplLnBsdXJhbGl6ZSgwLCB1bml0KTtcbiAgICAgIH1cblxuICAgICAgLy8gRXhwb3NlIHRoZXNlIGFzIG92ZXJyaWRhYmxlcz9cbiAgICAgIHZhciBwcmVmaXggPSAnQXBwcm94aW1hdGVseSc7XG4gICAgICB2YXIgdGltZVVuaXQgPSB2b2lkIDA7XG4gICAgICB2YXIgcmVsYXRpdmVQYWNlID0gdm9pZCAwO1xuXG4gICAgICB2YXIgcmF0ZSA9IHZhbHVlIC8gaW50ZXJ2YWxNcztcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgVElNRV9GT1JNQVRTLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIC8vIGFzc3VtZXMgc29ydGVkIGxpc3RcbiAgICAgICAgdmFyIGYgPSBUSU1FX0ZPUk1BVFNbaV07XG4gICAgICAgIHJlbGF0aXZlUGFjZSA9IHJhdGUgKiBmLnZhbHVlO1xuICAgICAgICBpZiAocmVsYXRpdmVQYWNlID4gMSkge1xuICAgICAgICAgIHRpbWVVbml0ID0gZi5uYW1lO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFVzZSB0aGUgbGFzdCB0aW1lIHVuaXQgaWYgdGhlcmUgaXMgbm90aGluZyBzbWFsbGVyXG4gICAgICBpZiAoIXRpbWVVbml0KSB7XG4gICAgICAgIHByZWZpeCA9ICdMZXNzIHRoYW4nO1xuICAgICAgICByZWxhdGl2ZVBhY2UgPSAxO1xuICAgICAgICB0aW1lVW5pdCA9IFRJTUVfRk9STUFUU1tUSU1FX0ZPUk1BVFMubGVuZ3RoIC0gMV0ubmFtZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJvdW5kZWRQYWNlID0gTWF0aC5yb3VuZChyZWxhdGl2ZVBhY2UpO1xuICAgICAgdW5pdCA9IEh1bWFuaXplLnBsdXJhbGl6ZShyb3VuZGVkUGFjZSwgdW5pdCk7XG5cbiAgICAgIHJldHVybiBwcmVmaXggKyAnICcgKyByb3VuZGVkUGFjZSArICcgJyArIHVuaXQgKyAnIHBlciAnICsgdGltZVVuaXQ7XG4gICAgfSxcblxuXG4gICAgLy8gQ29udmVydHMgbmV3bGluZXMgdG8gPGJyLz4gdGFnc1xuICAgIG5sMmJyOiBmdW5jdGlvbiBubDJicihzdHJpbmcpIHtcbiAgICAgIHZhciByZXBsYWNlbWVudCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/ICc8YnIvPicgOiBhcmd1bWVudHNbMV07XG5cbiAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvXFxuL2csIHJlcGxhY2VtZW50KTtcbiAgICB9LFxuXG5cbiAgICAvLyBDb252ZXJ0cyA8YnIvPiB0YWdzIHRvIG5ld2xpbmVzXG4gICAgYnIybmw6IGZ1bmN0aW9uIGJyMm5sKHN0cmluZykge1xuICAgICAgdmFyIHJlcGxhY2VtZW50ID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8gJ1xcclxcbicgOiBhcmd1bWVudHNbMV07XG5cbiAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvXFw8YnJcXHMqXFwvP1xcPi9nLCByZXBsYWNlbWVudCk7XG4gICAgfSxcblxuXG4gICAgLy8gQ2FwaXRhbGl6ZXMgZmlyc3QgbGV0dGVyIGluIGEgc3RyaW5nXG4gICAgY2FwaXRhbGl6ZTogZnVuY3Rpb24gY2FwaXRhbGl6ZShzdHJpbmcpIHtcbiAgICAgIHZhciBkb3duQ2FzZVRhaWwgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IGFyZ3VtZW50c1sxXTtcblxuICAgICAgcmV0dXJuICcnICsgc3RyaW5nLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgKGRvd25DYXNlVGFpbCA/IHN0cmluZy5zbGljZSgxKS50b0xvd2VyQ2FzZSgpIDogc3RyaW5nLnNsaWNlKDEpKTtcbiAgICB9LFxuXG5cbiAgICAvLyBDYXBpdGFsaXplcyB0aGUgZmlyc3QgbGV0dGVyIG9mIGVhY2ggd29yZCBpbiBhIHN0cmluZ1xuICAgIGNhcGl0YWxpemVBbGw6IGZ1bmN0aW9uIGNhcGl0YWxpemVBbGwoc3RyaW5nKSB7XG4gICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoLyg/Ol58XFxzKVxcUy9nLCBmdW5jdGlvbiAoYSkge1xuICAgICAgICByZXR1cm4gYS50b1VwcGVyQ2FzZSgpO1xuICAgICAgfSk7XG4gICAgfSxcblxuXG4gICAgLy8gVGl0bGVjYXNlIHdvcmRzIGluIGEgc3RyaW5nLlxuICAgIHRpdGxlQ2FzZTogZnVuY3Rpb24gdGl0bGVDYXNlKHN0cmluZykge1xuICAgICAgdmFyIHNtYWxsV29yZHMgPSAvXFxiKGF8YW58YW5kfGF0fGJ1dHxieXxkZXxlbnxmb3J8aWZ8aW58b2Z8b258b3J8dGhlfHRvfHZpYXx2cz9cXC4/KVxcYi9pO1xuICAgICAgdmFyIGludGVybmFsQ2FwcyA9IC9cXFMrW0EtWl0rXFxTKi87XG4gICAgICB2YXIgc3BsaXRPbldoaXRlU3BhY2VSZWdleCA9IC9cXHMrLztcbiAgICAgIHZhciBzcGxpdE9uSHlwaGVuc1JlZ2V4ID0gLy0vO1xuXG4gICAgICB2YXIgX2RvVGl0bGVDYXNlID0gdm9pZCAwO1xuICAgICAgX2RvVGl0bGVDYXNlID0gZnVuY3Rpb24gZG9UaXRsZUNhc2UoX3N0cmluZykge1xuICAgICAgICB2YXIgaHlwaGVuYXRlZCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogYXJndW1lbnRzWzFdO1xuICAgICAgICB2YXIgZmlyc3RPckxhc3QgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDIgfHwgYXJndW1lbnRzWzJdID09PSB1bmRlZmluZWQgPyB0cnVlIDogYXJndW1lbnRzWzJdO1xuXG4gICAgICAgIHZhciB0aXRsZUNhc2VkQXJyYXkgPSBbXTtcbiAgICAgICAgdmFyIHN0cmluZ0FycmF5ID0gX3N0cmluZy5zcGxpdChoeXBoZW5hdGVkID8gc3BsaXRPbkh5cGhlbnNSZWdleCA6IHNwbGl0T25XaGl0ZVNwYWNlUmVnZXgpO1xuXG4gICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBzdHJpbmdBcnJheS5sZW5ndGg7ICsraW5kZXgpIHtcbiAgICAgICAgICB2YXIgd29yZCA9IHN0cmluZ0FycmF5W2luZGV4XTtcbiAgICAgICAgICBpZiAod29yZC5pbmRleE9mKCctJykgIT09IC0xKSB7XG4gICAgICAgICAgICB0aXRsZUNhc2VkQXJyYXkucHVzaChfZG9UaXRsZUNhc2Uod29yZCwgdHJ1ZSwgaW5kZXggPT09IDAgfHwgaW5kZXggPT09IHN0cmluZ0FycmF5Lmxlbmd0aCAtIDEpKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChmaXJzdE9yTGFzdCAmJiAoaW5kZXggPT09IDAgfHwgaW5kZXggPT09IHN0cmluZ0FycmF5Lmxlbmd0aCAtIDEpKSB7XG4gICAgICAgICAgICB0aXRsZUNhc2VkQXJyYXkucHVzaChpbnRlcm5hbENhcHMudGVzdCh3b3JkKSA/IHdvcmQgOiBIdW1hbml6ZS5jYXBpdGFsaXplKHdvcmQpKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpbnRlcm5hbENhcHMudGVzdCh3b3JkKSkge1xuICAgICAgICAgICAgdGl0bGVDYXNlZEFycmF5LnB1c2god29yZCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChzbWFsbFdvcmRzLnRlc3Qod29yZCkpIHtcbiAgICAgICAgICAgIHRpdGxlQ2FzZWRBcnJheS5wdXNoKHdvcmQudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRpdGxlQ2FzZWRBcnJheS5wdXNoKEh1bWFuaXplLmNhcGl0YWxpemUod29yZCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aXRsZUNhc2VkQXJyYXkuam9pbihoeXBoZW5hdGVkID8gJy0nIDogJyAnKTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBfZG9UaXRsZUNhc2Uoc3RyaW5nKTtcbiAgICB9LFxuICAgIHRpdGxlY2FzZTogZnVuY3Rpb24gdGl0bGVjYXNlKCkge1xuICAgICAgcmV0dXJuIEh1bWFuaXplLnRpdGxlQ2FzZS5hcHBseShIdW1hbml6ZSwgYXJndW1lbnRzKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIEh1bWFuaXplO1xufSk7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/humanize-plus/dist/humanize.js\n");

/***/ })

};
;
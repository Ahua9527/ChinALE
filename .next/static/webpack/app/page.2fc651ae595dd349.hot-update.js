"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/utils/ale.ts":
/*!**************************!*\
  !*** ./src/utils/ale.ts ***!
  \**************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ALEConverter: () => (/* binding */ ALEConverter)\n/* harmony export */ });\n/* harmony import */ var iconv_lite__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! iconv-lite */ \"(app-pages-browser)/./node_modules/iconv-lite/lib/index.js\");\n/* harmony import */ var iconv_lite__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(iconv_lite__WEBPACK_IMPORTED_MODULE_0__);\n\nclass ALEConverter {\n    /**\n   * 将UTF-8编码的ALE文件内容转换为GBK编码\n   * @param file - 要转换的File对象\n   * @returns 转换后的Blob对象\n   */ static async convertToGBK(file) {\n        try {\n            // 读取文件内容\n            const buffer = await file.arrayBuffer();\n            // 将UTF-8解码为字符串\n            const utf8Decoder = new TextDecoder('utf-8');\n            const text = utf8Decoder.decode(buffer);\n            // 解析ALE文件结构\n            const aleData = this.parseALEFile(text);\n            // 将数据转换为GBK编码\n            const serializedText = this.serializeALEFile(aleData);\n            // 使用iconv-lite进行GBK编码\n            const gbkBuffer = iconv_lite__WEBPACK_IMPORTED_MODULE_0___default().encode(serializedText, 'gbk');\n            return new Blob([\n                gbkBuffer\n            ], {\n                type: 'text/plain;charset=gbk'\n            });\n        } catch (error) {\n            throw new Error(\"ALE文件转换失败: \".concat(error instanceof Error ? error.message : '未知错误'));\n        }\n    }\n    /**\n   * 解析ALE文件内容\n   * @param text - ALE文件文本内容\n   * @returns 解析后的ALE文件对象\n   */ static parseALEFile(text) {\n        const lines = text.split('\\n').filter((line)=>line.trim() !== '');\n        // 解析头部\n        const header = lines[0];\n        // 解析列头\n        const columnHeaders = lines[1].split('\\t');\n        // 解析数据行\n        const data = lines.slice(2).map((line)=>line.split('\\t'));\n        return {\n            header,\n            columnHeaders,\n            data\n        };\n    }\n    /**\n   * 将ALE文件对象序列化为字符串\n   * @param aleData - ALE文件对象\n   * @returns 序列化后的字符串\n   */ static serializeALEFile(aleData) {\n        const lines = [\n            aleData.header,\n            aleData.columnHeaders.join('\\t'),\n            ...aleData.data.map((row)=>row.join('\\t'))\n        ];\n        return lines.join('\\n');\n    }\n    /**\n   * 验证ALE文件格式\n   * @param file - 要验证的文件\n   * @returns 是否是有效的ALE文件\n   */ static async validateALEFile(file) {\n        try {\n            const buffer = await file.arrayBuffer();\n            const text = new TextDecoder('utf-8').decode(buffer);\n            const lines = text.split('\\n').filter((line)=>line.trim() !== '');\n            // 基本格式验证\n            return lines.length >= 3 && lines[0].startsWith('FIELD_DELIM') && lines[1].split('\\t').length > 1;\n        } catch (e) {\n            return false;\n        }\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy91dGlscy9hbGUudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQStCO0FBRXhCLE1BQU1DO0lBQ1g7Ozs7R0FJQyxHQUNELGFBQWFDLGFBQWFDLElBQVUsRUFBaUI7UUFDbkQsSUFBSTtZQUNGLFNBQVM7WUFDVCxNQUFNQyxTQUFTLE1BQU1ELEtBQUtFLFdBQVc7WUFFckMsZUFBZTtZQUNmLE1BQU1DLGNBQWMsSUFBSUMsWUFBWTtZQUNwQyxNQUFNQyxPQUFPRixZQUFZRyxNQUFNLENBQUNMO1lBRWhDLFlBQVk7WUFDWixNQUFNTSxVQUFVLElBQUksQ0FBQ0MsWUFBWSxDQUFDSDtZQUVsQyxjQUFjO1lBQ2QsTUFBTUksaUJBQWlCLElBQUksQ0FBQ0MsZ0JBQWdCLENBQUNIO1lBRTdDLHNCQUFzQjtZQUN0QixNQUFNSSxZQUFZZCx3REFBWSxDQUFDWSxnQkFBZ0I7WUFFL0MsT0FBTyxJQUFJSSxLQUFLO2dCQUFDRjthQUFVLEVBQUU7Z0JBQUVHLE1BQU07WUFBeUI7UUFFaEUsRUFBRSxPQUFPQyxPQUFPO1lBQ2QsTUFBTSxJQUFJQyxNQUFNLGNBQThELE9BQWhERCxpQkFBaUJDLFFBQVFELE1BQU1FLE9BQU8sR0FBRztRQUN6RTtJQUNGO0lBRUE7Ozs7R0FJQyxHQUNELE9BQWVULGFBQWFILElBQVksRUFBVztRQUNqRCxNQUFNYSxRQUFRYixLQUFLYyxLQUFLLENBQUMsTUFBTUMsTUFBTSxDQUFDQyxDQUFBQSxPQUFRQSxLQUFLQyxJQUFJLE9BQU87UUFFOUQsT0FBTztRQUNQLE1BQU1DLFNBQVNMLEtBQUssQ0FBQyxFQUFFO1FBRXZCLE9BQU87UUFDUCxNQUFNTSxnQkFBZ0JOLEtBQUssQ0FBQyxFQUFFLENBQUNDLEtBQUssQ0FBQztRQUVyQyxRQUFRO1FBQ1IsTUFBTU0sT0FBT1AsTUFBTVEsS0FBSyxDQUFDLEdBQUdDLEdBQUcsQ0FBQ04sQ0FBQUEsT0FBUUEsS0FBS0YsS0FBSyxDQUFDO1FBRW5ELE9BQU87WUFDTEk7WUFDQUM7WUFDQUM7UUFDRjtJQUNGO0lBRUE7Ozs7R0FJQyxHQUNELE9BQWVmLGlCQUFpQkgsT0FBZ0IsRUFBVTtRQUN4RCxNQUFNVyxRQUFRO1lBQ1pYLFFBQVFnQixNQUFNO1lBQ2RoQixRQUFRaUIsYUFBYSxDQUFDSSxJQUFJLENBQUM7ZUFDeEJyQixRQUFRa0IsSUFBSSxDQUFDRSxHQUFHLENBQUNFLENBQUFBLE1BQU9BLElBQUlELElBQUksQ0FBQztTQUNyQztRQUVELE9BQU9WLE1BQU1VLElBQUksQ0FBQztJQUNwQjtJQUVBOzs7O0dBSUMsR0FDRCxhQUFhRSxnQkFBZ0I5QixJQUFVLEVBQW9CO1FBQ3pELElBQUk7WUFDRixNQUFNQyxTQUFTLE1BQU1ELEtBQUtFLFdBQVc7WUFDckMsTUFBTUcsT0FBTyxJQUFJRCxZQUFZLFNBQVNFLE1BQU0sQ0FBQ0w7WUFDN0MsTUFBTWlCLFFBQVFiLEtBQUtjLEtBQUssQ0FBQyxNQUFNQyxNQUFNLENBQUNDLENBQUFBLE9BQVFBLEtBQUtDLElBQUksT0FBTztZQUU5RCxTQUFTO1lBQ1QsT0FBT0osTUFBTWEsTUFBTSxJQUFJLEtBQ2hCYixLQUFLLENBQUMsRUFBRSxDQUFDYyxVQUFVLENBQUMsa0JBQ3BCZCxLQUFLLENBQUMsRUFBRSxDQUFDQyxLQUFLLENBQUMsTUFBTVksTUFBTSxHQUFHO1FBQ3ZDLEVBQUUsVUFBTTtZQUNOLE9BQU87UUFDVDtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9kZWFraW5zL0RvY3VtZW50cy9BTEUyR0JLLUNvbnZlcnRlci9zcmMvdXRpbHMvYWxlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBpY29udiBmcm9tICdpY29udi1saXRlJztcblxuZXhwb3J0IGNsYXNzIEFMRUNvbnZlcnRlciB7XG4gIC8qKlxuICAgKiDlsIZVVEYtOOe8lueggeeahEFMReaWh+S7tuWGheWuuei9rOaNouS4ukdCS+e8lueggVxuICAgKiBAcGFyYW0gZmlsZSAtIOimgei9rOaNoueahEZpbGXlr7nosaFcbiAgICogQHJldHVybnMg6L2s5o2i5ZCO55qEQmxvYuWvueixoVxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGNvbnZlcnRUb0dCSyhmaWxlOiBGaWxlKTogUHJvbWlzZTxCbG9iPiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIOivu+WPluaWh+S7tuWGheWuuVxuICAgICAgY29uc3QgYnVmZmVyID0gYXdhaXQgZmlsZS5hcnJheUJ1ZmZlcigpO1xuICAgICAgXG4gICAgICAvLyDlsIZVVEYtOOino+eggeS4uuWtl+espuS4slxuICAgICAgY29uc3QgdXRmOERlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoJ3V0Zi04Jyk7XG4gICAgICBjb25zdCB0ZXh0ID0gdXRmOERlY29kZXIuZGVjb2RlKGJ1ZmZlcik7XG4gICAgICBcbiAgICAgIC8vIOino+aekEFMReaWh+S7tue7k+aehFxuICAgICAgY29uc3QgYWxlRGF0YSA9IHRoaXMucGFyc2VBTEVGaWxlKHRleHQpO1xuICAgICAgXG4gICAgICAvLyDlsIbmlbDmja7ovazmjaLkuLpHQkvnvJbnoIFcbiAgICAgIGNvbnN0IHNlcmlhbGl6ZWRUZXh0ID0gdGhpcy5zZXJpYWxpemVBTEVGaWxlKGFsZURhdGEpO1xuICAgICAgXG4gICAgICAvLyDkvb/nlKhpY29udi1saXRl6L+b6KGMR0JL57yW56CBXG4gICAgICBjb25zdCBnYmtCdWZmZXIgPSBpY29udi5lbmNvZGUoc2VyaWFsaXplZFRleHQsICdnYmsnKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIG5ldyBCbG9iKFtnYmtCdWZmZXJdLCB7IHR5cGU6ICd0ZXh0L3BsYWluO2NoYXJzZXQ9Z2JrJyB9KTtcbiAgICAgIFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEFMReaWh+S7tui9rOaNouWksei0pTogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICfmnKrnn6XplJnor68nfWApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiDop6PmnpBBTEXmlofku7blhoXlrrlcbiAgICogQHBhcmFtIHRleHQgLSBBTEXmlofku7bmlofmnKzlhoXlrrlcbiAgICogQHJldHVybnMg6Kej5p6Q5ZCO55qEQUxF5paH5Lu25a+56LGhXG4gICAqL1xuICBwcml2YXRlIHN0YXRpYyBwYXJzZUFMRUZpbGUodGV4dDogc3RyaW5nKTogQUxFRmlsZSB7XG4gICAgY29uc3QgbGluZXMgPSB0ZXh0LnNwbGl0KCdcXG4nKS5maWx0ZXIobGluZSA9PiBsaW5lLnRyaW0oKSAhPT0gJycpO1xuICAgIFxuICAgIC8vIOino+aekOWktOmDqFxuICAgIGNvbnN0IGhlYWRlciA9IGxpbmVzWzBdO1xuICAgIFxuICAgIC8vIOino+aekOWIl+WktFxuICAgIGNvbnN0IGNvbHVtbkhlYWRlcnMgPSBsaW5lc1sxXS5zcGxpdCgnXFx0Jyk7XG4gICAgXG4gICAgLy8g6Kej5p6Q5pWw5o2u6KGMXG4gICAgY29uc3QgZGF0YSA9IGxpbmVzLnNsaWNlKDIpLm1hcChsaW5lID0+IGxpbmUuc3BsaXQoJ1xcdCcpKTtcbiAgICBcbiAgICByZXR1cm4ge1xuICAgICAgaGVhZGVyLFxuICAgICAgY29sdW1uSGVhZGVycyxcbiAgICAgIGRhdGFcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIOWwhkFMReaWh+S7tuWvueixoeW6j+WIl+WMluS4uuWtl+espuS4slxuICAgKiBAcGFyYW0gYWxlRGF0YSAtIEFMReaWh+S7tuWvueixoVxuICAgKiBAcmV0dXJucyDluo/liJfljJblkI7nmoTlrZfnrKbkuLJcbiAgICovXG4gIHByaXZhdGUgc3RhdGljIHNlcmlhbGl6ZUFMRUZpbGUoYWxlRGF0YTogQUxFRmlsZSk6IHN0cmluZyB7XG4gICAgY29uc3QgbGluZXMgPSBbXG4gICAgICBhbGVEYXRhLmhlYWRlcixcbiAgICAgIGFsZURhdGEuY29sdW1uSGVhZGVycy5qb2luKCdcXHQnKSxcbiAgICAgIC4uLmFsZURhdGEuZGF0YS5tYXAocm93ID0+IHJvdy5qb2luKCdcXHQnKSlcbiAgICBdO1xuICAgIFxuICAgIHJldHVybiBsaW5lcy5qb2luKCdcXG4nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiDpqozor4FBTEXmlofku7bmoLzlvI9cbiAgICogQHBhcmFtIGZpbGUgLSDopoHpqozor4HnmoTmlofku7ZcbiAgICogQHJldHVybnMg5piv5ZCm5piv5pyJ5pWI55qEQUxF5paH5Lu2XG4gICAqL1xuICBzdGF0aWMgYXN5bmMgdmFsaWRhdGVBTEVGaWxlKGZpbGU6IEZpbGUpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgYnVmZmVyID0gYXdhaXQgZmlsZS5hcnJheUJ1ZmZlcigpO1xuICAgICAgY29uc3QgdGV4dCA9IG5ldyBUZXh0RGVjb2RlcigndXRmLTgnKS5kZWNvZGUoYnVmZmVyKTtcbiAgICAgIGNvbnN0IGxpbmVzID0gdGV4dC5zcGxpdCgnXFxuJykuZmlsdGVyKGxpbmUgPT4gbGluZS50cmltKCkgIT09ICcnKTtcbiAgICAgIFxuICAgICAgLy8g5Z+65pys5qC85byP6aqM6K+BXG4gICAgICByZXR1cm4gbGluZXMubGVuZ3RoID49IDMgJiYgXG4gICAgICAgICAgICAgbGluZXNbMF0uc3RhcnRzV2l0aCgnRklFTERfREVMSU0nKSAmJiBcbiAgICAgICAgICAgICBsaW5lc1sxXS5zcGxpdCgnXFx0JykubGVuZ3RoID4gMTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbn1cblxuaW50ZXJmYWNlIEFMRUZpbGUge1xuICBoZWFkZXI6IHN0cmluZztcbiAgY29sdW1uSGVhZGVyczogc3RyaW5nW107XG4gIGRhdGE6IHN0cmluZ1tdW107XG59XG4iXSwibmFtZXMiOlsiaWNvbnYiLCJBTEVDb252ZXJ0ZXIiLCJjb252ZXJ0VG9HQksiLCJmaWxlIiwiYnVmZmVyIiwiYXJyYXlCdWZmZXIiLCJ1dGY4RGVjb2RlciIsIlRleHREZWNvZGVyIiwidGV4dCIsImRlY29kZSIsImFsZURhdGEiLCJwYXJzZUFMRUZpbGUiLCJzZXJpYWxpemVkVGV4dCIsInNlcmlhbGl6ZUFMRUZpbGUiLCJnYmtCdWZmZXIiLCJlbmNvZGUiLCJCbG9iIiwidHlwZSIsImVycm9yIiwiRXJyb3IiLCJtZXNzYWdlIiwibGluZXMiLCJzcGxpdCIsImZpbHRlciIsImxpbmUiLCJ0cmltIiwiaGVhZGVyIiwiY29sdW1uSGVhZGVycyIsImRhdGEiLCJzbGljZSIsIm1hcCIsImpvaW4iLCJyb3ciLCJ2YWxpZGF0ZUFMRUZpbGUiLCJsZW5ndGgiLCJzdGFydHNXaXRoIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/utils/ale.ts\n"));

/***/ })

});
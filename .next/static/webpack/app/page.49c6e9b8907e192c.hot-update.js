"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/utils/ale.ts":
/*!**************************!*\
  !*** ./src/utils/ale.ts ***!
  \**************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ALEConverter: () => (/* binding */ ALEConverter),\n/* harmony export */   ALEError: () => (/* binding */ ALEError)\n/* harmony export */ });\n/**\n * ALE (Avid Log Exchange) 文件编码转换工具\n */ // 自定义错误类型\nclass ALEError extends Error {\n    constructor(message, errorType){\n        super(message), this.errorType = errorType;\n        this.name = 'ALEError';\n    }\n}\nclass ALEConverter {\n    /**\n   * 将UTF-8编码的ALE文件内容转换为GBK编码\n   */ static async convertToGBK(file) {\n        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        const finalOptions = {\n            ...this.DEFAULT_OPTIONS,\n            ...options\n        };\n        try {\n            // 检查文件大小\n            if (file.size > finalOptions.maxFileSize) {\n                throw new ALEError(\"文件大小超过限制: \".concat(file.size, \" bytes\"), 'FILE_SIZE');\n            }\n            // 验证文件格式\n            if (!await this.validateALEFile(file)) {\n                throw new ALEError('无效的ALE文件格式', 'FORMAT');\n            }\n            // 读取文件内容\n            const buffer = await this.readFileWithProgress(file, finalOptions.onProgress);\n            const text = await this.decodeUTF8(buffer);\n            // 解析ALE文件结构\n            const aleData = await this.parseALEFile(text);\n            // 序列化并转换编码\n            const serializedText = this.serializeALEFile(aleData);\n            // 这里应该使用专门的编码转换库，这里用简化实现作为示例\n            const gbkBuffer = await this.convertToGBKEncoding(serializedText, finalOptions);\n            return new Blob([\n                gbkBuffer\n            ], {\n                type: 'text/plain;charset=gbk'\n            });\n        } catch (error) {\n            if (error instanceof ALEError) {\n                throw error;\n            }\n            throw new ALEError(\"ALE文件转换失败: \".concat(error instanceof Error ? error.message : '未知错误'), 'ENCODING');\n        }\n    }\n    /**\n   * 使用进度回调读取文件\n   */ static async readFileWithProgress(file, onProgress) {\n        return new Promise((resolve, reject)=>{\n            const reader = new FileReader();\n            reader.onprogress = (event)=>{\n                if (event.lengthComputable) {\n                    onProgress(event.loaded / event.total);\n                }\n            };\n            reader.onload = ()=>resolve(reader.result);\n            reader.onerror = ()=>reject(new ALEError('文件读取失败', 'READ_ERROR'));\n            reader.readAsArrayBuffer(file);\n        });\n    }\n    /**\n   * UTF-8解码\n   */ static async decodeUTF8(buffer) {\n        try {\n            const decoder = new TextDecoder('utf-8', {\n                fatal: true\n            });\n            return decoder.decode(buffer);\n        } catch (error) {\n            throw new ALEError('UTF-8解码失败', 'ENCODING');\n        }\n    }\n    /**\n   * 解析ALE文件内容\n   */ static async parseALEFile(text) {\n        const lines = text.split('\\n').filter((line)=>line.trim() !== '');\n        if (lines.length < 3) {\n            throw new ALEError('文件格式无效：行数不足', 'FORMAT');\n        }\n        const header = lines[0];\n        if (!header.startsWith('FIELD_DELIM')) {\n            throw new ALEError('文件格式无效：缺少必要的头信息', 'FORMAT');\n        }\n        const columnHeaders = lines[1].split('\\t');\n        if (columnHeaders.length < 2) {\n            throw new ALEError('文件格式无效：列头格式错误', 'FORMAT');\n        }\n        const data = lines.slice(2).map((line)=>{\n            const row = line.split('\\t');\n            if (row.length !== columnHeaders.length) {\n                throw new ALEError('数据行列数与列头不匹配', 'FORMAT');\n            }\n            return row;\n        });\n        return {\n            header,\n            columnHeaders,\n            data\n        };\n    }\n    /**\n   * 转换为GBK编码\n   * 注意：这是简化实现，实际应该使用专门的编码转换库\n   */ static async convertToGBKEncoding(text, options) {\n        // 这里应该使用专门的编码转换库\n        // 下面是简化实现，仅作示例\n        const buffer = new Uint8Array(text.length * 2); // 预留足够空间\n        let offset = 0;\n        for(let i = 0; i < text.length; i++){\n            const char = text.charAt(i);\n            const code = text.charCodeAt(i);\n            if (code <= 0x7F) {\n                // ASCII\n                buffer[offset++] = code;\n            } else {\n                // 非ASCII字符\n                switch(options.errorStrategy){\n                    case 'SKIP':\n                        continue;\n                    case 'REPLACE':\n                        buffer[offset++] = options.replacementChar.charCodeAt(0);\n                        break;\n                    case 'THROW':\n                        throw new ALEError(\"无法转换字符: \".concat(char, \" (\").concat(code.toString(16), \")\"), 'ENCODING');\n                }\n            }\n        }\n        return buffer.slice(0, offset);\n    }\n    /**\n   * 验证ALE文件格式\n   */ static async validateALEFile(file) {\n        // 检查文件扩展名\n        if (!file.name.toLowerCase().endsWith('.ale')) {\n            return false;\n        }\n        try {\n            const buffer = await file.arrayBuffer();\n            const text = new TextDecoder('utf-8').decode(buffer);\n            const lines = text.split('\\n').filter((line)=>line.trim() !== '');\n            // 基本格式验证\n            if (lines.length < 3 || !lines[0].startsWith('FIELD_DELIM')) {\n                return false;\n            }\n            // 验证列头\n            const columnHeaders = lines[1].split('\\t');\n            if (columnHeaders.length < 2) {\n                return false;\n            }\n            // 验证数据行\n            const isValidDataRow = (row)=>{\n                const columns = row.split('\\t');\n                return columns.length === columnHeaders.length;\n            };\n            return lines.slice(2).every(isValidDataRow);\n        } catch (e) {\n            return false;\n        }\n    }\n    /**\n   * 序列化ALE文件\n   */ static serializeALEFile(aleData) {\n        return [\n            aleData.header,\n            aleData.columnHeaders.join('\\t'),\n            ...aleData.data.map((row)=>row.join('\\t'))\n        ].join('\\n');\n    }\n}\nALEConverter.DEFAULT_OPTIONS = {\n    maxFileSize: 50 * 1024 * 1024,\n    onProgress: ()=>{},\n    errorStrategy: 'REPLACE',\n    replacementChar: '?'\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QixFQUFFLFVBQU07WUFDTixPQUFPO1FBQ1Q7SUFDRjtJQUVBOztHQUVDLEdBQ0QsT0FBZWxELGlCQUFpQkgsT0FBZ0IsRUFBVTtRQUN4RCxPQUFPO1lBQ0xBLFFBQVFpQyxNQUFNO1lBQ2RqQyxRQUFRbUMsYUFBYSxDQUFDcUIsSUFBSSxDQUFDO2VBQ3hCeEQsUUFBUW9DLElBQUksQ0FBQ0UsR0FBRyxDQUFDQyxDQUFBQSxNQUFPQSxJQUFJaUIsSUFBSSxDQUFDO1NBQ3JDLENBQUNBLElBQUksQ0FBQztJQUNUO0FBQ0Y7QUFqTmF0RSxhQUNhSyxrQkFBK0M7SUFDckVFLGFBQWEsS0FBSyxPQUFPO0lBQ3pCSSxZQUFZLEtBQU87SUFDbkJrRCxlQUFlO0lBQ2ZDLGlCQUFpQjtBQUNuQiIsInNvdXJjZXMiOlsiL1VzZXJzL2RlYWtpbnMvRG9jdW1lbnRzL0FMRTJHQkstQ29udmVydGVyL3NyYy91dGlscy9hbGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBBTEUgKEF2aWQgTG9nIEV4Y2hhbmdlKSDmlofku7bnvJbnoIHovazmjaLlt6XlhbdcbiAqL1xuXG4vLyDoh6rlrprkuYnplJnor6/nsbvlnotcbmV4cG9ydCBjbGFzcyBBTEVFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoXG4gICAgbWVzc2FnZTogc3RyaW5nLFxuICAgIHB1YmxpYyByZWFkb25seSBlcnJvclR5cGU6ICdGT1JNQVQnIHwgJ0VOQ09ESU5HJyB8ICdGSUxFX1NJWkUnIHwgJ1JFQURfRVJST1InXG4gICkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMubmFtZSA9ICdBTEVFcnJvcic7XG4gIH1cbn1cblxuLy8g6L2s5o2i6YCJ6aG55o6l5Y+jXG5pbnRlcmZhY2UgQ29udmVyc2lvbk9wdGlvbnMge1xuICBtYXhGaWxlU2l6ZT86IG51bWJlcjtcbiAgb25Qcm9ncmVzcz86IChwcm9ncmVzczogbnVtYmVyKSA9PiB2b2lkO1xuICBlcnJvclN0cmF0ZWd5PzogJ1NLSVAnIHwgJ1JFUExBQ0UnIHwgJ1RIUk9XJztcbiAgcmVwbGFjZW1lbnRDaGFyPzogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgQUxFRmlsZSB7XG4gIGhlYWRlcjogc3RyaW5nO1xuICBjb2x1bW5IZWFkZXJzOiBzdHJpbmdbXTtcbiAgZGF0YTogc3RyaW5nW11bXTtcbn1cblxuZXhwb3J0IGNsYXNzIEFMRUNvbnZlcnRlciB7XG4gIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IERFRkFVTFRfT1BUSU9OUzogUmVxdWlyZWQ8Q29udmVyc2lvbk9wdGlvbnM+ID0ge1xuICAgIG1heEZpbGVTaXplOiA1MCAqIDEwMjQgKiAxMDI0LCAvLyA1ME1CXG4gICAgb25Qcm9ncmVzczogKCkgPT4ge30sXG4gICAgZXJyb3JTdHJhdGVneTogJ1JFUExBQ0UnLFxuICAgIHJlcGxhY2VtZW50Q2hhcjogJz8nXG4gIH07XG5cbiAgLyoqXG4gICAqIOWwhlVURi0457yW56CB55qEQUxF5paH5Lu25YaF5a656L2s5o2i5Li6R0JL57yW56CBXG4gICAqL1xuICBzdGF0aWMgYXN5bmMgY29udmVydFRvR0JLKFxuICAgIGZpbGU6IEZpbGUsXG4gICAgb3B0aW9uczogQ29udmVyc2lvbk9wdGlvbnMgPSB7fVxuICApOiBQcm9taXNlPEJsb2I+IHtcbiAgICBjb25zdCBmaW5hbE9wdGlvbnMgPSB7IC4uLnRoaXMuREVGQVVMVF9PUFRJT05TLCAuLi5vcHRpb25zIH07XG5cbiAgICB0cnkge1xuICAgICAgLy8g5qOA5p+l5paH5Lu25aSn5bCPXG4gICAgICBpZiAoZmlsZS5zaXplID4gZmluYWxPcHRpb25zLm1heEZpbGVTaXplKSB7XG4gICAgICAgIHRocm93IG5ldyBBTEVFcnJvcihcbiAgICAgICAgICBg5paH5Lu25aSn5bCP6LaF6L+H6ZmQ5Yi2OiAke2ZpbGUuc2l6ZX0gYnl0ZXNgLFxuICAgICAgICAgICdGSUxFX1NJWkUnXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIC8vIOmqjOivgeaWh+S7tuagvOW8j1xuICAgICAgaWYgKCFhd2FpdCB0aGlzLnZhbGlkYXRlQUxFRmlsZShmaWxlKSkge1xuICAgICAgICB0aHJvdyBuZXcgQUxFRXJyb3IoJ+aXoOaViOeahEFMReaWh+S7tuagvOW8jycsICdGT1JNQVQnKTtcbiAgICAgIH1cblxuICAgICAgLy8g6K+75Y+W5paH5Lu25YaF5a65XG4gICAgICBjb25zdCBidWZmZXIgPSBhd2FpdCB0aGlzLnJlYWRGaWxlV2l0aFByb2dyZXNzKGZpbGUsIGZpbmFsT3B0aW9ucy5vblByb2dyZXNzKTtcbiAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCB0aGlzLmRlY29kZVVURjgoYnVmZmVyKTtcbiAgICAgIFxuICAgICAgLy8g6Kej5p6QQUxF5paH5Lu257uT5p6EXG4gICAgICBjb25zdCBhbGVEYXRhID0gYXdhaXQgdGhpcy5wYXJzZUFMRUZpbGUodGV4dCk7XG4gICAgICBcbiAgICAgIC8vIOW6j+WIl+WMluW5tui9rOaNoue8lueggVxuICAgICAgY29uc3Qgc2VyaWFsaXplZFRleHQgPSB0aGlzLnNlcmlhbGl6ZUFMRUZpbGUoYWxlRGF0YSk7XG4gICAgICBcbiAgICAgIC8vIOi/memHjOW6lOivpeS9v+eUqOS4k+mXqOeahOe8lueggei9rOaNouW6k++8jOi/memHjOeUqOeugOWMluWunueOsOS9nOS4uuekuuS+i1xuICAgICAgY29uc3QgZ2JrQnVmZmVyID0gYXdhaXQgdGhpcy5jb252ZXJ0VG9HQktFbmNvZGluZyhcbiAgICAgICAgc2VyaWFsaXplZFRleHQsXG4gICAgICAgIGZpbmFsT3B0aW9uc1xuICAgICAgKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIG5ldyBCbG9iKFtnYmtCdWZmZXJdLCB7IHR5cGU6ICd0ZXh0L3BsYWluO2NoYXJzZXQ9Z2JrJyB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgQUxFRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgQUxFRXJyb3IoXG4gICAgICAgIGBBTEXmlofku7bovazmjaLlpLHotKU6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAn5pyq55+l6ZSZ6K+vJ31gLFxuICAgICAgICAnRU5DT0RJTkcnXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiDkvb/nlKjov5vluqblm57osIPor7vlj5bmlofku7ZcbiAgICovXG4gIHByaXZhdGUgc3RhdGljIGFzeW5jIHJlYWRGaWxlV2l0aFByb2dyZXNzKFxuICAgIGZpbGU6IEZpbGUsXG4gICAgb25Qcm9ncmVzczogKHByb2dyZXNzOiBudW1iZXIpID0+IHZvaWRcbiAgKTogUHJvbWlzZTxBcnJheUJ1ZmZlcj4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgcmVhZGVyLm9ucHJvZ3Jlc3MgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKGV2ZW50Lmxlbmd0aENvbXB1dGFibGUpIHtcbiAgICAgICAgICBvblByb2dyZXNzKGV2ZW50LmxvYWRlZCAvIGV2ZW50LnRvdGFsKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJlYWRlci5vbmxvYWQgPSAoKSA9PiByZXNvbHZlKHJlYWRlci5yZXN1bHQgYXMgQXJyYXlCdWZmZXIpO1xuICAgICAgcmVhZGVyLm9uZXJyb3IgPSAoKSA9PiByZWplY3QobmV3IEFMRUVycm9yKCfmlofku7bor7vlj5blpLHotKUnLCAnUkVBRF9FUlJPUicpKTtcbiAgICAgIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihmaWxlKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVVEYtOOino+eggVxuICAgKi9cbiAgcHJpdmF0ZSBzdGF0aWMgYXN5bmMgZGVjb2RlVVRGOChidWZmZXI6IEFycmF5QnVmZmVyKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigndXRmLTgnLCB7IGZhdGFsOiB0cnVlIH0pO1xuICAgICAgcmV0dXJuIGRlY29kZXIuZGVjb2RlKGJ1ZmZlcik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBBTEVFcnJvcignVVRGLTjop6PnoIHlpLHotKUnLCAnRU5DT0RJTkcnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICog6Kej5p6QQUxF5paH5Lu25YaF5a65XG4gICAqL1xuICBwcml2YXRlIHN0YXRpYyBhc3luYyBwYXJzZUFMRUZpbGUodGV4dDogc3RyaW5nKTogUHJvbWlzZTxBTEVGaWxlPiB7XG4gICAgY29uc3QgbGluZXMgPSB0ZXh0LnNwbGl0KCdcXG4nKS5maWx0ZXIobGluZSA9PiBsaW5lLnRyaW0oKSAhPT0gJycpO1xuICAgIFxuICAgIGlmIChsaW5lcy5sZW5ndGggPCAzKSB7XG4gICAgICB0aHJvdyBuZXcgQUxFRXJyb3IoJ+aWh+S7tuagvOW8j+aXoOaViO+8muihjOaVsOS4jei2sycsICdGT1JNQVQnKTtcbiAgICB9XG5cbiAgICBjb25zdCBoZWFkZXIgPSBsaW5lc1swXTtcbiAgICBpZiAoIWhlYWRlci5zdGFydHNXaXRoKCdGSUVMRF9ERUxJTScpKSB7XG4gICAgICB0aHJvdyBuZXcgQUxFRXJyb3IoJ+aWh+S7tuagvOW8j+aXoOaViO+8mue8uuWwkeW/heimgeeahOWktOS/oeaBrycsICdGT1JNQVQnKTtcbiAgICB9XG5cbiAgICBjb25zdCBjb2x1bW5IZWFkZXJzID0gbGluZXNbMV0uc3BsaXQoJ1xcdCcpO1xuICAgIGlmIChjb2x1bW5IZWFkZXJzLmxlbmd0aCA8IDIpIHtcbiAgICAgIHRocm93IG5ldyBBTEVFcnJvcign5paH5Lu25qC85byP5peg5pWI77ya5YiX5aS05qC85byP6ZSZ6K+vJywgJ0ZPUk1BVCcpO1xuICAgIH1cblxuICAgIGNvbnN0IGRhdGEgPSBsaW5lcy5zbGljZSgyKS5tYXAobGluZSA9PiB7XG4gICAgICBjb25zdCByb3cgPSBsaW5lLnNwbGl0KCdcXHQnKTtcbiAgICAgIGlmIChyb3cubGVuZ3RoICE9PSBjb2x1bW5IZWFkZXJzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgQUxFRXJyb3IoJ+aVsOaNruihjOWIl+aVsOS4juWIl+WktOS4jeWMuemFjScsICdGT1JNQVQnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByb3c7XG4gICAgfSk7XG5cbiAgICByZXR1cm4geyBoZWFkZXIsIGNvbHVtbkhlYWRlcnMsIGRhdGEgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiDovazmjaLkuLpHQkvnvJbnoIFcbiAgICog5rOo5oSP77ya6L+Z5piv566A5YyW5a6e546w77yM5a6e6ZmF5bqU6K+l5L2/55So5LiT6Zeo55qE57yW56CB6L2s5o2i5bqTXG4gICAqL1xuICBwcml2YXRlIHN0YXRpYyBhc3luYyBjb252ZXJ0VG9HQktFbmNvZGluZyhcbiAgICB0ZXh0OiBzdHJpbmcsXG4gICAgb3B0aW9uczogUmVxdWlyZWQ8Q29udmVyc2lvbk9wdGlvbnM+XG4gICk6IFByb21pc2U8VWludDhBcnJheT4ge1xuICAgIC8vIOi/memHjOW6lOivpeS9v+eUqOS4k+mXqOeahOe8lueggei9rOaNouW6k1xuICAgIC8vIOS4i+mdouaYr+eugOWMluWunueOsO+8jOS7heS9nOekuuS+i1xuICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KHRleHQubGVuZ3RoICogMik7IC8vIOmihOeVmei2s+Wkn+epuumXtFxuICAgIGxldCBvZmZzZXQgPSAwO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjaGFyID0gdGV4dC5jaGFyQXQoaSk7XG4gICAgICBjb25zdCBjb2RlID0gdGV4dC5jaGFyQ29kZUF0KGkpO1xuXG4gICAgICBpZiAoY29kZSA8PSAweDdGKSB7XG4gICAgICAgIC8vIEFTQ0lJXG4gICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBjb2RlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8g6Z2eQVNDSUnlrZfnrKZcbiAgICAgICAgc3dpdGNoIChvcHRpb25zLmVycm9yU3RyYXRlZ3kpIHtcbiAgICAgICAgICBjYXNlICdTS0lQJzpcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIGNhc2UgJ1JFUExBQ0UnOlxuICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IG9wdGlvbnMucmVwbGFjZW1lbnRDaGFyLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdUSFJPVyc6XG4gICAgICAgICAgICB0aHJvdyBuZXcgQUxFRXJyb3IoXG4gICAgICAgICAgICAgIGDml6Dms5XovazmjaLlrZfnrKY6ICR7Y2hhcn0gKCR7Y29kZS50b1N0cmluZygxNil9KWAsXG4gICAgICAgICAgICAgICdFTkNPRElORydcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYnVmZmVyLnNsaWNlKDAsIG9mZnNldCk7XG4gIH1cblxuICAvKipcbiAgICog6aqM6K+BQUxF5paH5Lu25qC85byPXG4gICAqL1xuICBzdGF0aWMgYXN5bmMgdmFsaWRhdGVBTEVGaWxlKGZpbGU6IEZpbGUpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICAvLyDmo4Dmn6Xmlofku7bmianlsZXlkI1cbiAgICBpZiAoIWZpbGUubmFtZS50b0xvd2VyQ2FzZSgpLmVuZHNXaXRoKCcuYWxlJykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgYnVmZmVyID0gYXdhaXQgZmlsZS5hcnJheUJ1ZmZlcigpO1xuICAgICAgY29uc3QgdGV4dCA9IG5ldyBUZXh0RGVjb2RlcigndXRmLTgnKS5kZWNvZGUoYnVmZmVyKTtcbiAgICAgIGNvbnN0IGxpbmVzID0gdGV4dC5zcGxpdCgnXFxuJykuZmlsdGVyKGxpbmUgPT4gbGluZS50cmltKCkgIT09ICcnKTtcbiAgICAgIFxuICAgICAgLy8g5Z+65pys5qC85byP6aqM6K+BXG4gICAgICBpZiAobGluZXMubGVuZ3RoIDwgMyB8fCAhbGluZXNbMF0uc3RhcnRzV2l0aCgnRklFTERfREVMSU0nKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIOmqjOivgeWIl+WktFxuICAgICAgY29uc3QgY29sdW1uSGVhZGVycyA9IGxpbmVzWzFdLnNwbGl0KCdcXHQnKTtcbiAgICAgIGlmIChjb2x1bW5IZWFkZXJzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvLyDpqozor4HmlbDmja7ooYxcbiAgICAgIGNvbnN0IGlzVmFsaWREYXRhUm93ID0gKHJvdzogc3RyaW5nKSA9PiB7XG4gICAgICAgIGNvbnN0IGNvbHVtbnMgPSByb3cuc3BsaXQoJ1xcdCcpO1xuICAgICAgICByZXR1cm4gY29sdW1ucy5sZW5ndGggPT09IGNvbHVtbkhlYWRlcnMubGVuZ3RoO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIGxpbmVzLnNsaWNlKDIpLmV2ZXJ5KGlzVmFsaWREYXRhUm93KTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICog5bqP5YiX5YyWQUxF5paH5Lu2XG4gICAqL1xuICBwcml2YXRlIHN0YXRpYyBzZXJpYWxpemVBTEVGaWxlKGFsZURhdGE6IEFMRUZpbGUpOiBzdHJpbmcge1xuICAgIHJldHVybiBbXG4gICAgICBhbGVEYXRhLmhlYWRlcixcbiAgICAgIGFsZURhdGEuY29sdW1uSGVhZGVycy5qb2luKCdcXHQnKSxcbiAgICAgIC4uLmFsZURhdGEuZGF0YS5tYXAocm93ID0+IHJvdy5qb2luKCdcXHQnKSlcbiAgICBdLmpvaW4oJ1xcbicpO1xuICB9XG59Il0sIm5hbWVzIjpbIkFMRUVycm9yIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsIm1lc3NhZ2UiLCJlcnJvclR5cGUiLCJuYW1lIiwiQUxFQ29udmVydGVyIiwiY29udmVydFRvR0JLIiwiZmlsZSIsIm9wdGlvbnMiLCJmaW5hbE9wdGlvbnMiLCJERUZBVUxUX09QVElPTlMiLCJzaXplIiwibWF4RmlsZVNpemUiLCJ2YWxpZGF0ZUFMRUZpbGUiLCJidWZmZXIiLCJyZWFkRmlsZVdpdGhQcm9ncmVzcyIsIm9uUHJvZ3Jlc3MiLCJ0ZXh0IiwiZGVjb2RlVVRGOCIsImFsZURhdGEiLCJwYXJzZUFMRUZpbGUiLCJzZXJpYWxpemVkVGV4dCIsInNlcmlhbGl6ZUFMRUZpbGUiLCJnYmtCdWZmZXIiLCJjb252ZXJ0VG9HQktFbmNvZGluZyIsIkJsb2IiLCJ0eXBlIiwiZXJyb3IiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsInJlYWRlciIsIkZpbGVSZWFkZXIiLCJvbnByb2dyZXNzIiwiZXZlbnQiLCJsZW5ndGhDb21wdXRhYmxlIiwibG9hZGVkIiwidG90YWwiLCJvbmxvYWQiLCJyZXN1bHQiLCJvbmVycm9yIiwicmVhZEFzQXJyYXlCdWZmZXIiLCJkZWNvZGVyIiwiVGV4dERlY29kZXIiLCJmYXRhbCIsImRlY29kZSIsImxpbmVzIiwic3BsaXQiLCJmaWx0ZXIiLCJsaW5lIiwidHJpbSIsImxlbmd0aCIsImhlYWRlciIsInN0YXJ0c1dpdGgiLCJjb2x1bW5IZWFkZXJzIiwiZGF0YSIsInNsaWNlIiwibWFwIiwicm93IiwiVWludDhBcnJheSIsIm9mZnNldCIsImkiLCJjaGFyIiwiY2hhckF0IiwiY29kZSIsImNoYXJDb2RlQXQiLCJlcnJvclN0cmF0ZWd5IiwicmVwbGFjZW1lbnRDaGFyIiwidG9TdHJpbmciLCJ0b0xvd2VyQ2FzZSIsImVuZHNXaXRoIiwiYXJyYXlCdWZmZXIiLCJpc1ZhbGlkRGF0YVJvdyIsImNvbHVtbnMiLCJldmVyeSIsImpvaW4iXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/utils/ale.ts\n"));

/***/ })

});
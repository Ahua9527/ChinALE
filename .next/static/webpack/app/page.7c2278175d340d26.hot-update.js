"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/utils/ale.ts":
/*!**************************!*\
  !*** ./src/utils/ale.ts ***!
  \**************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ALEConverter: () => (/* binding */ ALEConverter)\n/* harmony export */ });\n/**\n * ALE (Avid Log Exchange) 文件编码转换工具\n */ class ALEConverter {\n    /**\n   * 将UTF-8编码的ALE文件内容转换为GBK编码\n   * @param file - 要转换的File对象\n   * @returns 转换后的Blob对象\n   */ static async convertToGBK(file) {\n        try {\n            // 读取文件内容\n            const buffer = await file.arrayBuffer();\n            // 将UTF-8解码为字符串\n            const utf8Decoder = new TextDecoder('utf-8');\n            const text = utf8Decoder.decode(buffer);\n            // 解析ALE文件结构\n            const aleData = this.parseALEFile(text);\n            // 将数据转换为GBK编码\n            const serializedText = this.serializeALEFile(aleData);\n            // 使用TextDecoder进行GBK编码\n            const gbkBuffer = new Uint8Array(serializedText.length);\n            for(let i = 0; i < serializedText.length; i++){\n                const charCode = serializedText.charCodeAt(i);\n                // 处理ASCII范围\n                if (charCode <= 0x7F) {\n                    gbkBuffer[i] = charCode;\n                } else {\n                    // 处理中文字符\n                    const char = text.charAt(i);\n                    const encoded = unescape(encodeURIComponent(char));\n                    gbkBuffer[i] = encoded.charCodeAt(0);\n                }\n            }\n            return new Blob([\n                gbkBuffer\n            ], {\n                type: 'text/plain;charset=gbk'\n            });\n        } catch (error) {\n            throw new Error(\"ALE文件转换失败: \".concat(error instanceof Error ? error.message : '未知错误'));\n        }\n    }\n    /**\n   * 解析ALE文件内容\n   * @param text - ALE文件文本内容\n   * @returns 解析后的ALE文件对象\n   */ static parseALEFile(text) {\n        const lines = text.split('\\n').filter((line)=>line.trim() !== '');\n        // 解析头部\n        const header = lines[0];\n        // 解析列头\n        const columnHeaders = lines[1].split('\\t');\n        // 解析数据行\n        const data = lines.slice(2).map((line)=>line.split('\\t'));\n        return {\n            header,\n            columnHeaders,\n            data\n        };\n    }\n    /**\n   * 将ALE文件对象序列化为字符串\n   * @param aleData - ALE文件对象\n   * @returns 序列化后的字符串\n   */ static serializeALEFile(aleData) {\n        const lines = [\n            aleData.header,\n            aleData.columnHeaders.join('\\t'),\n            ...aleData.data.map((row)=>row.join('\\t'))\n        ];\n        return lines.join('\\n');\n    }\n    /**\n   * 验证ALE文件格式\n   * @param file - 要验证的文件\n   * @returns 是否是有效的ALE文件\n   */ static async validateALEFile(file) {\n        try {\n            const buffer = await file.arrayBuffer();\n            const text = new TextDecoder('utf-8').decode(buffer);\n            const lines = text.split('\\n').filter((line)=>line.trim() !== '');\n            // 基本格式验证\n            return lines.length >= 3 && lines[0].startsWith('FIELD_DELIM') && lines[1].split('\\t').length > 1;\n        } catch (e) {\n            return false;\n        }\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy91dGlscy9hbGUudHMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBOztDQUVDLEdBUU0sTUFBTUE7SUFDWDs7OztHQUlDLEdBQ0QsYUFBYUMsYUFBYUMsSUFBVSxFQUFpQjtRQUNuRCxJQUFJO1lBQ0YsU0FBUztZQUNULE1BQU1DLFNBQVMsTUFBTUQsS0FBS0UsV0FBVztZQUVyQyxlQUFlO1lBQ2YsTUFBTUMsY0FBYyxJQUFJQyxZQUFZO1lBQ3BDLE1BQU1DLE9BQU9GLFlBQVlHLE1BQU0sQ0FBQ0w7WUFFaEMsWUFBWTtZQUNaLE1BQU1NLFVBQVUsSUFBSSxDQUFDQyxZQUFZLENBQUNIO1lBRWxDLGNBQWM7WUFDZCxNQUFNSSxpQkFBaUIsSUFBSSxDQUFDQyxnQkFBZ0IsQ0FBQ0g7WUFFN0MsdUJBQXVCO1lBQ3ZCLE1BQU1JLFlBQVksSUFBSUMsV0FBV0gsZUFBZUksTUFBTTtZQUN0RCxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUwsZUFBZUksTUFBTSxFQUFFQyxJQUFLO2dCQUM5QyxNQUFNQyxXQUFXTixlQUFlTyxVQUFVLENBQUNGO2dCQUMzQyxZQUFZO2dCQUNaLElBQUlDLFlBQVksTUFBTTtvQkFDcEJKLFNBQVMsQ0FBQ0csRUFBRSxHQUFHQztnQkFDakIsT0FBTztvQkFDTCxTQUFTO29CQUNULE1BQU1FLE9BQU9aLEtBQUthLE1BQU0sQ0FBQ0o7b0JBQ3pCLE1BQU1LLFVBQVVDLFNBQVNDLG1CQUFtQko7b0JBQzVDTixTQUFTLENBQUNHLEVBQUUsR0FBR0ssUUFBUUgsVUFBVSxDQUFDO2dCQUNwQztZQUNGO1lBRUEsT0FBTyxJQUFJTSxLQUFLO2dCQUFDWDthQUFVLEVBQUU7Z0JBQUVZLE1BQU07WUFBeUI7UUFDaEUsRUFBRSxPQUFPQyxPQUFPO1lBQ2QsTUFBTSxJQUFJQyxNQUFNLGNBQThELE9BQWhERCxpQkFBaUJDLFFBQVFELE1BQU1FLE9BQU8sR0FBRztRQUN6RTtJQUNGO0lBRUE7Ozs7R0FJQyxHQUNELE9BQWVsQixhQUFhSCxJQUFZLEVBQVc7UUFDakQsTUFBTXNCLFFBQVF0QixLQUFLdUIsS0FBSyxDQUFDLE1BQU1DLE1BQU0sQ0FBQ0MsQ0FBQUEsT0FBUUEsS0FBS0MsSUFBSSxPQUFPO1FBRTlELE9BQU87UUFDUCxNQUFNQyxTQUFTTCxLQUFLLENBQUMsRUFBRTtRQUV2QixPQUFPO1FBQ1AsTUFBTU0sZ0JBQWdCTixLQUFLLENBQUMsRUFBRSxDQUFDQyxLQUFLLENBQUM7UUFFckMsUUFBUTtRQUNSLE1BQU1NLE9BQU9QLE1BQU1RLEtBQUssQ0FBQyxHQUFHQyxHQUFHLENBQUNOLENBQUFBLE9BQVFBLEtBQUtGLEtBQUssQ0FBQztRQUVuRCxPQUFPO1lBQ0xJO1lBQ0FDO1lBQ0FDO1FBQ0Y7SUFDRjtJQUVBOzs7O0dBSUMsR0FDRCxPQUFleEIsaUJBQWlCSCxPQUFnQixFQUFVO1FBQ3hELE1BQU1vQixRQUFRO1lBQ1pwQixRQUFReUIsTUFBTTtZQUNkekIsUUFBUTBCLGFBQWEsQ0FBQ0ksSUFBSSxDQUFDO2VBQ3hCOUIsUUFBUTJCLElBQUksQ0FBQ0UsR0FBRyxDQUFDRSxDQUFBQSxNQUFPQSxJQUFJRCxJQUFJLENBQUM7U0FDckM7UUFFRCxPQUFPVixNQUFNVSxJQUFJLENBQUM7SUFDcEI7SUFFQTs7OztHQUlDLEdBQ0QsYUFBYUUsZ0JBQWdCdkMsSUFBVSxFQUFvQjtRQUN6RCxJQUFJO1lBQ0YsTUFBTUMsU0FBUyxNQUFNRCxLQUFLRSxXQUFXO1lBQ3JDLE1BQU1HLE9BQU8sSUFBSUQsWUFBWSxTQUFTRSxNQUFNLENBQUNMO1lBQzdDLE1BQU0wQixRQUFRdEIsS0FBS3VCLEtBQUssQ0FBQyxNQUFNQyxNQUFNLENBQUNDLENBQUFBLE9BQVFBLEtBQUtDLElBQUksT0FBTztZQUU5RCxTQUFTO1lBQ1QsT0FBT0osTUFBTWQsTUFBTSxJQUFJLEtBQ2hCYyxLQUFLLENBQUMsRUFBRSxDQUFDYSxVQUFVLENBQUMsa0JBQ3BCYixLQUFLLENBQUMsRUFBRSxDQUFDQyxLQUFLLENBQUMsTUFBTWYsTUFBTSxHQUFHO1FBQ3ZDLEVBQUUsVUFBTTtZQUNOLE9BQU87UUFDVDtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9kZWFraW5zL0RvY3VtZW50cy9BTEUyR0JLLUNvbnZlcnRlci9zcmMvdXRpbHMvYWxlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQUxFIChBdmlkIExvZyBFeGNoYW5nZSkg5paH5Lu257yW56CB6L2s5o2i5bel5YW3XG4gKi9cblxuaW50ZXJmYWNlIEFMRUZpbGUge1xuICBoZWFkZXI6IHN0cmluZztcbiAgY29sdW1uSGVhZGVyczogc3RyaW5nW107XG4gIGRhdGE6IHN0cmluZ1tdW107XG59XG5cbmV4cG9ydCBjbGFzcyBBTEVDb252ZXJ0ZXIge1xuICAvKipcbiAgICog5bCGVVRGLTjnvJbnoIHnmoRBTEXmlofku7blhoXlrrnovazmjaLkuLpHQkvnvJbnoIFcbiAgICogQHBhcmFtIGZpbGUgLSDopoHovazmjaLnmoRGaWxl5a+56LGhXG4gICAqIEByZXR1cm5zIOi9rOaNouWQjueahEJsb2Llr7nosaFcbiAgICovXG4gIHN0YXRpYyBhc3luYyBjb252ZXJ0VG9HQksoZmlsZTogRmlsZSk6IFByb21pc2U8QmxvYj4ge1xuICAgIHRyeSB7XG4gICAgICAvLyDor7vlj5bmlofku7blhoXlrrlcbiAgICAgIGNvbnN0IGJ1ZmZlciA9IGF3YWl0IGZpbGUuYXJyYXlCdWZmZXIoKTtcbiAgICAgIFxuICAgICAgLy8g5bCGVVRGLTjop6PnoIHkuLrlrZfnrKbkuLJcbiAgICAgIGNvbnN0IHV0ZjhEZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCd1dGYtOCcpO1xuICAgICAgY29uc3QgdGV4dCA9IHV0ZjhEZWNvZGVyLmRlY29kZShidWZmZXIpO1xuICAgICAgXG4gICAgICAvLyDop6PmnpBBTEXmlofku7bnu5PmnoRcbiAgICAgIGNvbnN0IGFsZURhdGEgPSB0aGlzLnBhcnNlQUxFRmlsZSh0ZXh0KTtcbiAgICAgIFxuICAgICAgLy8g5bCG5pWw5o2u6L2s5o2i5Li6R0JL57yW56CBXG4gICAgICBjb25zdCBzZXJpYWxpemVkVGV4dCA9IHRoaXMuc2VyaWFsaXplQUxFRmlsZShhbGVEYXRhKTtcbiAgICAgIFxuICAgICAgLy8g5L2/55SoVGV4dERlY29kZXLov5vooYxHQkvnvJbnoIFcbiAgICAgIGNvbnN0IGdia0J1ZmZlciA9IG5ldyBVaW50OEFycmF5KHNlcmlhbGl6ZWRUZXh0Lmxlbmd0aCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlcmlhbGl6ZWRUZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNoYXJDb2RlID0gc2VyaWFsaXplZFRleHQuY2hhckNvZGVBdChpKTtcbiAgICAgICAgLy8g5aSE55CGQVNDSUnojIPlm7RcbiAgICAgICAgaWYgKGNoYXJDb2RlIDw9IDB4N0YpIHtcbiAgICAgICAgICBnYmtCdWZmZXJbaV0gPSBjaGFyQ29kZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyDlpITnkIbkuK3mloflrZfnrKZcbiAgICAgICAgICBjb25zdCBjaGFyID0gdGV4dC5jaGFyQXQoaSk7XG4gICAgICAgICAgY29uc3QgZW5jb2RlZCA9IHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChjaGFyKSk7XG4gICAgICAgICAgZ2JrQnVmZmVyW2ldID0gZW5jb2RlZC5jaGFyQ29kZUF0KDApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiBuZXcgQmxvYihbZ2JrQnVmZmVyXSwgeyB0eXBlOiAndGV4dC9wbGFpbjtjaGFyc2V0PWdiaycgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQUxF5paH5Lu26L2s5o2i5aSx6LSlOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ+acquefpemUmeivryd9YCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIOino+aekEFMReaWh+S7tuWGheWuuVxuICAgKiBAcGFyYW0gdGV4dCAtIEFMReaWh+S7tuaWh+acrOWGheWuuVxuICAgKiBAcmV0dXJucyDop6PmnpDlkI7nmoRBTEXmlofku7blr7nosaFcbiAgICovXG4gIHByaXZhdGUgc3RhdGljIHBhcnNlQUxFRmlsZSh0ZXh0OiBzdHJpbmcpOiBBTEVGaWxlIHtcbiAgICBjb25zdCBsaW5lcyA9IHRleHQuc3BsaXQoJ1xcbicpLmZpbHRlcihsaW5lID0+IGxpbmUudHJpbSgpICE9PSAnJyk7XG4gICAgXG4gICAgLy8g6Kej5p6Q5aS06YOoXG4gICAgY29uc3QgaGVhZGVyID0gbGluZXNbMF07XG4gICAgXG4gICAgLy8g6Kej5p6Q5YiX5aS0XG4gICAgY29uc3QgY29sdW1uSGVhZGVycyA9IGxpbmVzWzFdLnNwbGl0KCdcXHQnKTtcbiAgICBcbiAgICAvLyDop6PmnpDmlbDmja7ooYxcbiAgICBjb25zdCBkYXRhID0gbGluZXMuc2xpY2UoMikubWFwKGxpbmUgPT4gbGluZS5zcGxpdCgnXFx0JykpO1xuICAgIFxuICAgIHJldHVybiB7XG4gICAgICBoZWFkZXIsXG4gICAgICBjb2x1bW5IZWFkZXJzLFxuICAgICAgZGF0YVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICog5bCGQUxF5paH5Lu25a+56LGh5bqP5YiX5YyW5Li65a2X56ym5LiyXG4gICAqIEBwYXJhbSBhbGVEYXRhIC0gQUxF5paH5Lu25a+56LGhXG4gICAqIEByZXR1cm5zIOW6j+WIl+WMluWQjueahOWtl+espuS4slxuICAgKi9cbiAgcHJpdmF0ZSBzdGF0aWMgc2VyaWFsaXplQUxFRmlsZShhbGVEYXRhOiBBTEVGaWxlKTogc3RyaW5nIHtcbiAgICBjb25zdCBsaW5lcyA9IFtcbiAgICAgIGFsZURhdGEuaGVhZGVyLFxuICAgICAgYWxlRGF0YS5jb2x1bW5IZWFkZXJzLmpvaW4oJ1xcdCcpLFxuICAgICAgLi4uYWxlRGF0YS5kYXRhLm1hcChyb3cgPT4gcm93LmpvaW4oJ1xcdCcpKVxuICAgIF07XG4gICAgXG4gICAgcmV0dXJuIGxpbmVzLmpvaW4oJ1xcbicpO1xuICB9XG5cbiAgLyoqXG4gICAqIOmqjOivgUFMReaWh+S7tuagvOW8j1xuICAgKiBAcGFyYW0gZmlsZSAtIOimgemqjOivgeeahOaWh+S7tlxuICAgKiBAcmV0dXJucyDmmK/lkKbmmK/mnInmlYjnmoRBTEXmlofku7ZcbiAgICovXG4gIHN0YXRpYyBhc3luYyB2YWxpZGF0ZUFMRUZpbGUoZmlsZTogRmlsZSk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBidWZmZXIgPSBhd2FpdCBmaWxlLmFycmF5QnVmZmVyKCk7XG4gICAgICBjb25zdCB0ZXh0ID0gbmV3IFRleHREZWNvZGVyKCd1dGYtOCcpLmRlY29kZShidWZmZXIpO1xuICAgICAgY29uc3QgbGluZXMgPSB0ZXh0LnNwbGl0KCdcXG4nKS5maWx0ZXIobGluZSA9PiBsaW5lLnRyaW0oKSAhPT0gJycpO1xuICAgICAgXG4gICAgICAvLyDln7rmnKzmoLzlvI/pqozor4FcbiAgICAgIHJldHVybiBsaW5lcy5sZW5ndGggPj0gMyAmJiBcbiAgICAgICAgICAgICBsaW5lc1swXS5zdGFydHNXaXRoKCdGSUVMRF9ERUxJTScpICYmIFxuICAgICAgICAgICAgIGxpbmVzWzFdLnNwbGl0KCdcXHQnKS5sZW5ndGggPiAxO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbIkFMRUNvbnZlcnRlciIsImNvbnZlcnRUb0dCSyIsImZpbGUiLCJidWZmZXIiLCJhcnJheUJ1ZmZlciIsInV0ZjhEZWNvZGVyIiwiVGV4dERlY29kZXIiLCJ0ZXh0IiwiZGVjb2RlIiwiYWxlRGF0YSIsInBhcnNlQUxFRmlsZSIsInNlcmlhbGl6ZWRUZXh0Iiwic2VyaWFsaXplQUxFRmlsZSIsImdia0J1ZmZlciIsIlVpbnQ4QXJyYXkiLCJsZW5ndGgiLCJpIiwiY2hhckNvZGUiLCJjaGFyQ29kZUF0IiwiY2hhciIsImNoYXJBdCIsImVuY29kZWQiLCJ1bmVzY2FwZSIsImVuY29kZVVSSUNvbXBvbmVudCIsIkJsb2IiLCJ0eXBlIiwiZXJyb3IiLCJFcnJvciIsIm1lc3NhZ2UiLCJsaW5lcyIsInNwbGl0IiwiZmlsdGVyIiwibGluZSIsInRyaW0iLCJoZWFkZXIiLCJjb2x1bW5IZWFkZXJzIiwiZGF0YSIsInNsaWNlIiwibWFwIiwiam9pbiIsInJvdyIsInZhbGlkYXRlQUxFRmlsZSIsInN0YXJ0c1dpdGgiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/utils/ale.ts\n"));

/***/ })

});